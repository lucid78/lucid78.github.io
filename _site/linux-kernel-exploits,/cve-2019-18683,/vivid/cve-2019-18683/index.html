<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.21.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Linux Kernel Exploit with CVE-2019-18683 - Security Warehouse</title>
<meta name="description" content="linux kernel exploitation">


  <meta name="author" content="lucid7">
  
  <meta property="article:author" content="lucid7">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="Security Warehouse">
<meta property="og:title" content="Linux Kernel Exploit with CVE-2019-18683">
<meta property="og:url" content="https://lucid78.github.io/linux-kernel-exploits,/cve-2019-18683,/vivid/cve-2019-18683/">


  <meta property="og:description" content="linux kernel exploitation">







  <meta property="article:published_time" content="2021-08-02T00:00:00+09:00">





  

  


<link rel="canonical" href="https://lucid78.github.io/linux-kernel-exploits,/cve-2019-18683,/vivid/cve-2019-18683/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "lucid7",
      "url": "https://lucid78.github.io/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Security Warehouse Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single wide">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          Security Warehouse
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://mmistakes.github.io/minimal-mistakes/docs/quick-start-guide/">Quick-Start Guide</a>
            </li><li class="masthead__menu-item">
              <a href="/categories/">Category</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">lucid7</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>Well, I still have music.</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">Korea</span>
        </li>
      

      
        
          
            <li><a href="mailto:lucid78@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://lucid78.github.io" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Website</span></a></li>
          
        
          
        
          
        
          
            <li><a href="https://github.com/lucid78" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
          
        
      

      

      
        <li>
          <a href="mailto:lucid78@gmail.com">
            <meta itemprop="email" content="lucid78@gmail.com" />
            <i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span>
          </a>
        </li>
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Linux Kernel Exploit with CVE-2019-18683">
    <meta itemprop="description" content="linux kernel exploitation">
    <meta itemprop="datePublished" content="2021-08-02T00:00:00+09:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Linux Kernel Exploit with CVE-2019-18683
</h1>
          


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right ">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
              <ul class="toc__menu"><li><a href="#intro">Intro</a></li><li><a href="#environment-setting">Environment Setting</a></li><li><a href="#cve-2019-18683">CVE-2019-18683</a><ul><li><a href="#1-overview">1. Overview</a></li><li><a href="#2-v4l2">2. V4L2</a></li><li><a href="#3-read-과정-소스-분석">3. READ 과정 소스 분석</a><ul><li><a href="#31-v4l2_read">3.1 v4l2_read()</a></li><li><a href="#32-vb2_fop_read">3.2 vb2_fop_read()</a></li><li><a href="#33-vb2_read">3.3 vb2_read()</a></li><li><a href="#34-__vb2_perform_fileio">3.4 __vb2_perform_fileio()</a></li><li><a href="#341-__vb2_init_fileio">3.4.1 __vb2_init_fileio()</a><ul><li><a href="#3411-vb2_core_reqbufs">3.4.1.1 vb2_core_reqbufs()</a><ul><li><a href="#34111-__vb2_queue_alloc">3.4.1.1.1 __vb2_queue_alloc()</a></li><li><a href="#34112-__vb2_buf_mem_alloc">3.4.1.1.2 __vb2_buf_mem_alloc()</a></li></ul></li><li><a href="#3412-vb2_core_qbuf">3.4.1.2 vb2_core_qbuf()</a><ul><li><a href="#34121-vid_cap_buf_prepare">3.4.1.2.1 vid_cap_buf_prepare()</a></li><li><a href="#34122-__enqueue_in_driver">3.4.1.2.2 __enqueue_in_driver()</a></li><li><a href="#34123-vid_cap_buf_queue">3.4.1.2.3 vid_cap_buf_queue()</a></li></ul></li><li><a href="#3413-vb2_core_streamon">3.4.1.3 vb2_core_streamon()</a><ul><li><a href="#34131-vb2_start_streaming">3.4.1.3.1 vb2_start_streaming()</a></li><li><a href="#34132-vid_cap_start_streaming">3.4.1.3.2 vid_cap_start_streaming()</a></li><li><a href="#34133-vivid_start_generating_vid_cap">3.4.1.3.3 vivid_start_generating_vid_cap()</a></li><li><a href="#34134-vivid_thread_vid_cap_tick">3.4.1.3.4 vivid_thread_vid_cap_tick()</a></li><li><a href="#34135-vb2_buffer_done">3.4.1.3.5 vb2_buffer_done()</a></li></ul></li></ul></li><li><a href="#342-vb2_core_dqbuf">3.4.2 vb2_core_dqbuf()</a><ul><li><a href="#3421-__vb2_get_done_vb">3.4.2.1 __vb2_get_done_vb()</a><ul><li><a href="#34211-__vb2_wait_for_done_vb">3.4.2.1.1 __vb2_wait_for_done_vb()</a></li></ul></li></ul></li><li><a href="#343-copy_to_user">3.4.3 copy_to_user()</a></li></ul></li><li><a href="#4-close-과정-소스-분석">4. CLOSE 과정 소스 분석</a><ul><li><a href="#41-vivid_fop_release">4.1 vivid_fop_release()</a></li><li><a href="#42-_vb2_fop_release">4.2 _vb2_fop_release</a></li><li><a href="#43-vb2_core_queue_release">4.3 vb2_core_queue_release()</a><ul><li><a href="#431-__vb2_cleanup_fileio">4.3.1 __vb2_cleanup_fileio()</a><ul><li><a href="#4311-__vb2_queue_cancel">4.3.1.1 __vb2_queue_cancel()</a></li><li><a href="#43111-vivid_stop_generating_vid_cap">4.3.1.1.1 vivid_stop_generating_vid_cap()</a></li><li><a href="#4312-vb2_core_reqbufs">4.3.1.2 vb2_core_reqbufs()</a></li></ul></li></ul></li><li><a href="#432-__vb2_queue_cancel">4.3.2 __vb2_queue_cancel()</a></li><li><a href="#433-__vb2_queue_free">4.3.3 __vb2_queue_free()</a></li></ul></li><li><a href="#5-취약점-분석">5. 취약점 분석</a></li></ul></li><li><a href="#exploit-분석">Exploit 분석</a></li><li><a href="#reference">Reference</a></li></ul>

            </nav>
          </aside>
        
        <h2 id="intro"><strong>Intro</strong></h2>

<p>Alexander Popov가 발표한 CVE-2019-18683에 대해 분석해보자.</p>

<h2 id="environment-setting"><strong>Environment Setting</strong></h2>

<p>이번에는 qemu + virt-manager를 이용해서 조금 더 간단히 테스트 환경을 먼저 구축하도록 한다. 이 방법은 참고할 수 있는 문서들이 많으므로 간단하게 정리해본다.</p>

<p>먼저 아래의 명령을 이용하여 필요한 패키지를 설치한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>virt-manager qemu-kvm libvirt-daemon-system
</code></pre></div></div>

<p><br />그리고 qemu를 이용해서 ubuntu 18.04.3 server 버전을 설치한다. 자세한 설치 방법은 아래 링크에서 확인하도록 한다.
<br /><a href="https://wiki.whamcloud.com/display/LNet/Kernel+GDB+live+Debugging+with+KVM">Ubuntu KVM 설치</a></p>

<p>설치가 완료되면 아래의 명령을 통해 kernel과 module 모두 업그레이드를 한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt <span class="nb">install </span>linux-image-4.15.0-66-generic linux-modules-extra-4.15.0-66-generic
</code></pre></div></div>
<p><br />
원활한 kernel dubugging을 위해 grub을 수정하여 kaslr을 해제한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">GRUB_CMDLINE_LINUX_DEFAULT</span><span class="o">=</span><span class="s2">"quiet nokaslr"</span>
</code></pre></div></div>

<p><a href="/assets/images/cve-2019-18683/grub.png"><img src="/assets/images/cve-2019-18683/grub.png" alt="grub" /></a></p>

<p>cve-2019-18683은 vivid 드라이버에서 발생하는데, 이 드라이버는 자동으로 로드되지 않기 때문에 /etc/modules 파일을 수정하여 부팅 시마다 해당 드라이버가 로딩되도록 설정해야 한다.
<a href="/assets/images/cve-2019-18683/modules-set.png"><img src="/assets/images/cve-2019-18683/modules-set.png" alt="modules-set" /></a></p>

<p>재부팅 후 아래와 같이 해당 드라이버가 제대로 로딩되었는지 확인한다.
<a href="/assets/images/cve-2019-18683/load_vivid.png"><img src="/assets/images/cve-2019-18683/load_vivid.png" alt="load_vivid" /></a></p>

<p>KASLR이 해제되었는지는 dmesg를 통해 알 수 있다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dmesg | <span class="nb">grep command</span>
</code></pre></div></div>
<p><a href="/assets/images/cve-2019-18683/dmesg.png"><img src="/assets/images/cve-2019-18683/dmesg.png" alt="dmesg" /></a></p>

<p>비디오 장치가 제대로 올라왔는지도 확인해보자.
<a href="/assets/images/cve-2019-18683/device_vivid.png"><img src="/assets/images/cve-2019-18683/device_vivid.png" alt="device_vivid" /></a></p>

<p>마지막으로 해당 장치에 대한 사용자의 권한을 확인해보면, 사용자 lucid7이 user에 포함되어 있음을 볼 수 있다.
<a href="/assets/images/cve-2019-18683/getfacl.png"><img src="/assets/images/cve-2019-18683/getfacl.png" alt="getfacl" /></a></p>

<p>위의 권한들을 콘솔에서 로컬로 로그인을 수행해야만 활성화 되며, 단순히 ssh로 로그인 할 경우에는 활성화 되지 않으므로 주의해야 한다.</p>

<p><br />
이전 분석 문서의 <a href="https://lucid78.github.io/linux-kernel-exploits,/cve-2017-7308/cve-2017-7308/#1-virtualbox%EC%97%90-ubuntu-%EC%84%A4%EC%B9%98%ED%95%98%EA%B8%B0">테스트 환경 구축하기</a>를 참고하여 kernel binary, source, debug symbol을 host에 준비한다.</p>

<p>그리고 kernel debugging을 위해 아래와 같이 virt-manager에서 xml을 수정한다.<br />
자세한 내용은 <a href="https://wiki.whamcloud.com/display/LNet/Kernel+GDB+live+Debugging+with+KVM">Kernel GDB live Debugging with KVM</a>를 참고하도록 한다.</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;domain</span> <span class="na">xmlns:qemu=</span><span class="s">"http://libvirt.org/schemas/domain/qemu/1.0"</span> <span class="na">type=</span><span class="s">"kvm"</span><span class="nt">&gt;</span>

...

<span class="nt">&lt;qemu:commandline&gt;</span>
  <span class="nt">&lt;qemu:arg</span> <span class="na">value=</span><span class="s">"-gdb"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;qemu:arg</span> <span class="na">value=</span><span class="s">"tcp::1235"</span><span class="nt">/&gt;</span>
<span class="nt">&lt;/qemu:commandline&gt;</span>

<span class="nt">&lt;/domain&gt;</span>
</code></pre></div></div>

<p><br />guest를 재부팅 하고 아래 debug.dbg를 이용하여 gdb를 실행한다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">set </span>print pretty on

target remote localhost:1235
add-auto-load-safe-path <span class="nb">source</span>/linux-4.15/scripts/gdb/vmlinux-gdb.py
add-symbol-file symbol/vmlinux-4.15.0-66-generic 0
<span class="nb">source</span> /home/lucid7/Downloads/pwndbg/gdbinit.py
</code></pre></div></div>
<p><a href="/assets/images/cve-2019-18683/gdb.png"><img src="/assets/images/cve-2019-18683/gdb.png" alt="gdb" /></a></p>

<p>continue 후 ctrl+c로 interrupt를 걸어보면 소스를 찾을 수 없다는 에러 화면이 아래와 같이 발생하는데, 미리 준비했던 kernel source를 해당 디렉토리에 복사해 놓으면 된다.
<a href="/assets/images/cve-2019-18683/gdb_source_error.png"><img src="/assets/images/cve-2019-18683/gdb_source_error.png" alt="gdb_source_error" /></a></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="nb">sudo mkdir</span> /build/linux-WKYm23
 <span class="nb">sudo cp</span> <span class="nt">-r</span> linux-4.15 /build/linux-WKYm23/linux-4.15.0
</code></pre></div></div>

<p><br /></p>
<h2 id="cve-2019-18683"><strong>CVE-2019-18683</strong></h2>

<blockquote>
  <p>이 취약점에 대한 원문은 <a href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">CVE-2019-18683: Exploiting a Linux kernel  vulnerabiity in the V4L2 subsystem</a>에서 찾아볼 수 있다.</p>
</blockquote>

<p>이 취약점은 2020년 Alexander Popov가 발표한 local privilege escalation 취약점이다.</p>

<p>원문의 제목에 나타나 있는 것처럼 공격자는 V4L2라는 subsystem의 취약점을 이용해 KASLR/SMEP/SMAP을 우회하여 root 권한을 획득할 수 있다. 해당 취약점은 race condition 상태에서 발생하는 Use-After-Free 취약점이다.</p>

<h3 id="1-overview">1. Overview</h3>

<p>V4L2는 Video for Linux 2의 약자로써 Linux에서 video device를 다루기 위해 사용되는 framework의 version 2를 말한다.</p>

<blockquote>
  <p>V4L2 (Video for Linux) 와 Video Buffer 에 대해 간단하게 설명하면, V4L2는 Video streaming I/O 를 지원하기 위한 프레임워크이다. 스트리밍 API이므로 성능이 중요하고 userspace와 kernel 간의 메모리 교환에서 반드시 zero-copy가 이뤄져야 한다. 이 때문에 구현해야 하는 API들이 꽤 복잡하다. 복잡성을 조금이라도 줄이기 위해, 스트리밍에 사용하는 버퍼에 관련된 코드의 일관성을 유지하고자 나온 것이 현재의 Video Buffer 프레임워크이다(현재 버전은 2이다).<br />
https://seokbeomkim.github.io/posts/v4l2-dmabuf/</p>
</blockquote>

<p>device는 /dev/video0, /dev/video1 이라는 character device를 생성하기 때문에 사용자는 file descriptor을 이용하여 open(), read(), write(), close() 등의 API를 이용할 수 있다.</p>

<p>취약점은 V4L2를 기반으로 하는 virtual video kernel module 인 VIVI 에서 발견되었다. 이 모듈은 virtual video input device에 대한 장치 드라이버 역할을 하며, 시스템에 물리적 하드웨어 장치가 없는 상태에서도 V4L2 API를 사용하여 video device를 에뮬레이트 하는 기능을 가지고 있다.</p>

<p>ubuntu에서는 일반 사용자도 vivi 드라이버에 의해 생성된 장치에 대해 rw 권한을 가지고 있다.
<a href="/assets/images/cve-2019-18683/getfacl.png"><img src="/assets/images/cve-2019-18683/getfacl.png" alt="getfacl" /></a></p>

<p><br />vivi가 스트리밍을 다룰 때 잘못된 mutex에 대한 lock으로 인해 buffer queue에 대해 user-after-free 취약점이 발생하게 된다.
<br />아래는 문제가 발생하는 소스 부분이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* shutdown control thread */</span>
<span class="n">vivid_grab_controls</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="n">kthread_stop</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span><span class="p">);</span>
<span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></div></div>

<p>원문의 저자는 mutex가 unlock 되었을 때, 동시에 vb2_for_read() 함수에서 다시 mutex를 lock한 후 buffer queue를 조작하게 되면 스트리밍이 다시 시작되었을 때 use-after-free의 기회가 생길 수 있다고 설명하고 있다.</p>

<p>사실 V4L2가 어떻게 동작하는지 모르는 상황에서는 이 말이 무엇인지 알 수 없기 때문에, 먼저 V4L2에 관해 먼저 알아보는 것이 필요하다.</p>

<h3 id="2-v4l2">2. V4L2</h3>

<blockquote>
  <p>아래의 내용은 <a href="http://thirdnsov.tistory.com/attachment/cfile5.uf@26022A3A57BBB8120F3A86.pdf">Video for Linux Ver.2(V4L2)</a> 문서의 내용을 간략화 한 것이며, 자세한 정보는 해당 문서를 참고하기 바란다.</p>
</blockquote>

<p>일반적으로 V4L2를 이용한 스트리밍 처리의 순서는 아래와 같다. (IOCTL 기준)</p>

<p><a href="/assets/images/cve-2019-18683/v4l2_command.png"><img src="/assets/images/cve-2019-18683/v4l2_command.png" alt="v4l2_command" /></a></p>

<p>위의 그림은 Application에서 V4L2 드라이버로 보낼 명령(IOCTL)의 순서도를 간략히 나타낸 것이다. QBUF, DQBUF, STREAMON을 반복적으로 수행할 경우 영상을 얻을 수 있으며, 그렇지 않을 경우에는 스틸컷(1프레임)만 얻을 수 있다.</p>

<p><strong>QUERYCAP</strong>
<br />연결된 Device의 이름 및 수행 가능한 동작 등 장치 정보를 사용자 영역에 알려주는 역할을 한다. 이 명령이 수행되고 나면 아래와 같이 디바이스에 대한 정보를 출력할 수 있다.</p>

<p><strong>S_FMT_VID_CAP</strong>
<br />포맷이나 해상도 등의 설정을 하기 위해 수행되는 명령이다.</p>

<p><strong>REQBUF</strong>
<br />Device로부터 받아온 데이터를 저장하기 위한 buffer를 할당하는 역할을 하는 명령이다. 할당된 buffer는 queue에 저장된다.</p>

<p><strong>QUERYBUF &amp; MMAP</strong>
<br />특정  buffer의 정보를 요청할 때 사용되며, 사용자 영역에서 넘어온 buffer의 index 값을 이용하여 얻어온 buffer의 offset 정보를 바탕으로 mmap()을 호출하게 된다. mmap() 호출이 정상적으로 수행되고 난 후 해당 buffer는 사용자 영역의 buffer와 매핑되게 된다.</p>

<p><strong>QBUF</strong>
<br />Device에게 새로운 frame를 요청한다.</p>

<p><strong>STREAMON</strong>
<br />queue에 buffer를 연결한 후 Device의 스트림 기능을 활성화한 다음 가져온 이미지 정보를 decode 하고 buffer에 저장하는 역할을 한다. 이 명령 전후에 QBUF와 DQBUF를 요청해야만 Application이 이미지 정보를 얻어올 수 있다.</p>

<p><strong>DQBUF</strong>
<br />QBUF 수행으로 얻어진 frame의 index를 이용해 매핑된 메모리 영역으로부터 실제 이미지 데이터를 가져오는 기능을 수행한다. 이 명령으로 인해 이미지 데이터가 사용자 영역으로 넘어가게 된다.</p>

<p>지금까지 V4L2 드라이버로 보낼 명령(IOCTL)의 순서도를 통해 해당 기능들을 아주 간략히 알아보았다. 이 지식을 바탕으로 kernel source를 분석해 보자.</p>

<h3 id="3-read-과정-소스-분석">3. READ 과정 소스 분석</h3>

<p>vivid 드라이버는 디바이스 타입에 따라 has_vid_cap, has_vbi_cap 속성을 가진다. TV나 SVID 타입일 경우 has_vbi_cap 속성이, video capture device 의 경우 has_vid_cap 속성이 설정되며 이 속성에 따라 동작하는 드라이버가 구분된다.</p>

<p>여기서는 webcam 디바이스를 제어한다는 가정하에 has_vid_cap 속성을 가지는 것으로 간주하고 관련 소스를 살펴볼 것이다.</p>

<h4 id="31-v4l2_read">3.1 v4l2_read()</h4>

<p>어플리케이션에서 device의 file descriptor에 대한 read() 호출은 v4l2_read() 함수를 호출하도록 되어 있다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/v4l2-dev.c#L459</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">v4l2_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span> 		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span> 		<span class="o">=</span> <span class="n">v4l2_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span> 		<span class="o">=</span> <span class="n">v4l2_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span> 		<span class="o">=</span> <span class="n">v4l2_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">get_unmapped_area</span> 	<span class="o">=</span> <span class="n">v4l2_get_unmapped_area</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mmap</span> 		<span class="o">=</span> <span class="n">v4l2_mmap</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unlocked_ioctl</span> 	<span class="o">=</span> <span class="n">v4l2_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT
</span>    <span class="p">.</span><span class="n">compat_ioctl</span> 	<span class="o">=</span> <span class="n">v4l2_compat_ioctl32</span><span class="p">,</span>
<span class="cp">#endif
</span>    <span class="p">.</span><span class="n">release</span> 		<span class="o">=</span> <span class="n">v4l2_release</span><span class="p">,</span>
    <span class="p">.</span><span class="n">poll</span> 		<span class="o">=</span> <span class="n">v4l2_poll</span><span class="p">,</span>
    <span class="p">.</span><span class="n">llseek</span> 		<span class="o">=</span> <span class="n">no_llseek</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br />그리고 이 함수는 v4l2_file_operations 의 read() 함수 호출로 이어진다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/v4l2-dev.c#L300</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">v4l2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sz</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">video_is_registered</span><span class="p">(</span><span class="n">vdev</span><span class="p">))</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">fops</span><span class="o">-&gt;</span><span class="n">read</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="32-vb2_fop_read">3.2 vb2_fop_read()</h4>

<p>vdev-&gt;fops-&gt;read() 함수는 v4l2_file_operations 의 vb2_fop_read() 함수로 이어진다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-core.c#L494</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">v4l2_file_operations</span> <span class="n">vivid_fops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">owner</span>	    <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
    <span class="p">.</span><span class="n">open</span>           <span class="o">=</span> <span class="n">v4l2_fh_open</span><span class="p">,</span>
    <span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">vivid_fop_release</span><span class="p">,</span>
    <span class="p">.</span><span class="n">read</span>           <span class="o">=</span> <span class="n">vb2_fop_read</span><span class="p">,</span>
    <span class="p">.</span><span class="n">write</span>          <span class="o">=</span> <span class="n">vb2_fop_write</span><span class="p">,</span>
    <span class="p">.</span><span class="n">poll</span>	    <span class="o">=</span> <span class="n">vb2_fop_poll</span><span class="p">,</span>
    <span class="p">.</span><span class="n">unlocked_ioctl</span> <span class="o">=</span> <span class="n">video_ioctl2</span><span class="p">,</span>
    <span class="p">.</span><span class="n">mmap</span>           <span class="o">=</span> <span class="n">vb2_fop_mmap</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></div>

<p><br />vb2_fop_read() 함수는 적절한 권한 체크를 하고 lock을 걸고난 후 vb2_read()를 호출한다. vb2_read() 함수가 완료된 후 lock이 걸려 있으면 unlock을 하고 종료한다.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-v4l2.c#L883</span>
<span class="kt">ssize_t</span> <span class="nf">vb2_fop_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">video_devdata</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">?</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">:</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>	<span class="c1">// vdev-&gt;queue-&gt;lock == vdev-&gt;lock</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span> <span class="o">&amp;&amp;</span> <span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="n">lock</span><span class="p">))</span>	<span class="c1">// lock(vdev-&gt;queue-&gt;lock) == lock(vivid_dev-&gt;mutex)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">vb2_read</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">);</span>
    <span class="p">...</span>
<span class="nl">exit:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><br />취약점과 관련이 있는 mutex의 경우 좀 복잡하게 여러 이름으로 설정되어 있으나 create_instance() 함수를 보면 아래와 같이 정리가 가능하다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-core.c#L642</span>
<span class="k">struct</span> <span class="n">vivid_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vfd</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	
<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

<span class="n">q</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vb_vid_cap_q</span><span class="p">;</span>
<span class="n">q</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">;</span>
<span class="n">q</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">dev</span><span class="p">;</span>
	
<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">queue</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vb_vid_cap_q</span><span class="p">;</span>
<span class="n">vfd</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">;</span>
</code></pre></div></div>

<p>따라서 아래의 값은 모두 동일한 mutex를 가리킨다.</p>
<ul>
  <li>vivid_dev-&gt;mutex</li>
  <li>video_device-&gt;lock</li>
  <li>vivid_dev-&gt;vb_vid_cap_q-&gt;lock</li>
  <li>video_device-&gt;queue-&gt;lock</li>
</ul>

<p><br />위에서 정리한 동일한 mutex를 가리키는 각 변수들을 염두에 두고 소스 분석을 계속 진행해보자.</p>

<h4 id="33-vb2_read">3.3 vb2_read()</h4>

<p>vb2_read() 함수는 __vb2_perform_fileio() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-core.c#L2460</span>
<span class="kt">size_t</span> <span class="nf">vb2_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">__vb2_perform_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="34-__vb2_perform_fileio">3.4 __vb2_perform_fileio()</h4>

<p>이 함수는 아래와 같이 크게 3가지의 함수로 구분될 수 있다.</p>

<ol>
  <li>__vb2_init_fileio() : 스트리밍을 위해 필요한 준비 및 실제로 스트리밍을 하는 kernel thread를 생성시킨다.</li>
  <li>vb2_core_dqbuf() : 메모리로부터 데이터를 가져온다. 앞에서 살펴본 DQBUF에 해당한다.</li>
  <li>copy_to_user() : 데이터를 사용자 영역으로 넘겨주는 kernel api</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-core.c#L2305</span>
<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">__vb2_perform_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vb2_fileio_is_active</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span> 		<span class="c1">// q-&gt;fileio 검사</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_init_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">read</span><span class="p">);</span>   <span class="c1">// &lt;== 진입</span>
    <span class="p">...</span>
    <span class="p">}</span>
    <span class="n">fileio</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span><span class="p">;</span>

    <span class="c1">// __vb2_init_fileio() 함수에서 cur_index = q-&gt;num_buffers 로 설정되며 값은 2가 된다.</span>
    <span class="n">index</span> <span class="o">=</span> <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">cur_index</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// &lt;== 진입</span>
        <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

        <span class="c1">// vb2_core_dqbuf() 실행</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_core_dqbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">nonblock</span><span class="p">);</span>
	    <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">else</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vaddr</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">pos</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="err">}</span>
</code></pre></div></div>

<h4 id="341-__vb2_init_fileio">3.4.1 __vb2_init_fileio()</h4>

<p>이 함수도 아래와 같이 크게 3가지 함수로 구분할 수 있다.</p>

<ol>
  <li>vb2_core_reqbufs()</li>
  <li>vb2_core_qbuf()</li>
  <li>vb2_core_streamon()</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-core.c#L2163</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_init_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">read</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">vb2_fileio_data</span> <span class="o">*</span><span class="n">fileio</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">// vb2_fileio_data 구조체에 메모리 할당</span>
    <span class="n">fileio</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fileio</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fileio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

    <span class="c1">// fileio 구조체 내용 설정</span>
    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">read_once</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio_read_once</span><span class="p">;</span>
    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">write_immediately</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio_write_immediately</span><span class="p">;</span>
    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>              <span class="c1">// 1로 설정되어 있음</span>
    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">VB2_MEMORY_MMAP</span><span class="p">;</span>   <span class="c1">// mmap 방식의 버퍼 요청을 위한 서정</span>
    <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">fileio</span> <span class="o">=</span> <span class="n">fileio</span><span class="p">;</span>                 <span class="c1">// 설정한 fileio를 queue-&gt;fileio에 설정</span>

    <span class="c1">// 버퍼에 video memory를 할당하고, 할당된 vb2_buffer 버퍼의 갯수를 반환하는데,num_buffers에 의존하므로 이 값은 2임</span>
    <span class="c1">// 할당된 버퍼는 q-&gt;bufs[vb-&gt;index] 에 설정되고, 버퍼에 할당된 메모리 주소는 vb-&gt;planes[plane].mem_priv 에 설정</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_core_reqbufs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="c1">// plane는 오직 1개만 지원함</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// mmap 주소의 매핑된 kernel virtual address 를 반환</span>
        <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">vaddr</span> <span class="o">=</span> <span class="n">vb2_plane_vaddr</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">...</span>

        <span class="c1">// vb-&gt;planes[0].length 의 값이 저장됨</span>
        <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="n">vb2_plane_size</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span> <span class="p">{</span>	 <span class="c1">// &lt;== 진입</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 버퍼를 준비하는 과정을 실행하고 해당 버퍼를 vivid_dev-&gt;vbi_cap_active 리스트에 추가</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_core_qbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">err_reqbufs</span><span class="p">;</span>
            <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">queued</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">initial_index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>
        <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">cur_index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_core_streamon</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3411-vb2_core_reqbufs">3.4.1.1 vb2_core_reqbufs()</h5>

<p>이 함수는 vid_cap_queue_setup() 함수를 호출하여 필요한 버퍼 수와 버퍼 당  plane 수를 요청한 후, __vb2_queue_alloc() 함수를 통해 2개의 buffer를 할당한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vb2_core_reqbufs</span><span class="p">(</span> <span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                      <span class="k">enum</span> <span class="n">vb2_memory</span> <span class="n">memory</span><span class="p">,</span>    <span class="c1">// VB2_MEMORY_MMAP</span>
                      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>       <span class="c1">// 1</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="c1">// 만약 스트리밍 중일 경우에는 리턴</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">dprintk</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">"streaming active</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// count는 1로 강제 설정되어 넘어오므로 이 if문은 실행되지 않음</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">// #define VB2_MAX_FRAME	(32)</span>
    <span class="c1">// #define VB2_MAX_PLANES	(8)</span>
    <span class="n">num_buffers</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="o">*</span><span class="n">count</span><span class="p">,</span> <span class="n">VB2_MAX_FRAME</span><span class="p">);</span>   <span class="c1">// 1</span>
    
    <span class="c1">// q-&gt;min_buffers_needed 는 vivid_create_instance 함수에서 2로 설정되어 있음. 따라서 2개의 버퍼가 생성됨</span>
    <span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-core.c#L642</span>
    <span class="n">num_buffers</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">num_buffers</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">min_buffers_needed</span><span class="p">);</span>  <span class="c1">// 2</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_devs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_devs</span><span class="p">));</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="p">;</span> <span class="c1">// VB2_MEMORY_MMAP</span>

    <span class="c1">// Driver에게 필요한 버퍼 수와 버퍼 당 plane 수를 요청</span>
    <span class="c1">// Driver는 크기를 설정 및 각 plane 에 대한 컨텍스트 할당</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span> <span class="n">q</span><span class="p">,</span>
                    <span class="n">queue_setup</span><span class="p">,</span>    <span class="c1">// vid_cap_queue_setup() 호출</span>
                    <span class="n">q</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">num_buffers</span><span class="p">,</span>   <span class="c1">// 2</span>
                    <span class="o">&amp;</span><span class="n">num_planes</span><span class="p">,</span>
                    <span class="n">plane_sizes</span><span class="p">,</span>
                    <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_devs</span><span class="p">);</span>
    <span class="p">...</span>

    <span class="c1">// 버퍼에 video memory(vb2_buffer)를 할당하고, 할당된 vb2_buffer 버퍼의 갯수를 반환하는데, num_buffers에 의존하므로 2임</span>
    <span class="c1">// 할당된 버퍼는 q-&gt;bufs[vb-&gt;index] 에 설정되고, 버퍼에 할당된 메모리 주소는 vb-&gt;planes[plane].mem_priv 에 설정</span>
    <span class="n">allocated_buffers</span> <span class="o">=</span> <span class="n">__vb2_queue_alloc</span><span class="p">(</span> <span class="n">q</span><span class="p">,</span>
                                           <span class="n">memory</span><span class="p">,</span>         <span class="c1">// VB2_MEMORY_MMAP</span>
                                           <span class="n">num_buffers</span><span class="p">,</span>    <span class="c1">// 2</span>
                                           <span class="n">num_planes</span><span class="p">,</span>     <span class="c1">// 1</span>
                                           <span class="n">plane_sizes</span><span class="p">);</span>   <span class="c1">// plane_sizes[0] = size</span>
    <span class="p">...</span>

    <span class="c1">// 요청한 갯수보다 작은 갯수의 버퍼가 할당되었을 경우에 재시도</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">allocated_buffers</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="c1">// 할당된 버퍼의 갯수를 설정</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span>	<span class="c1">// 2</span>
    <span class="p">...</span>
    <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">allocated_buffers</span><span class="p">;</span> <span class="c1">// 할당된 버퍼의 갯수를 설정. 2</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34111-__vb2_queue_alloc">3.4.1.1.1 __vb2_queue_alloc()</h6>

<p>이 함수는 2개의 버퍼에 vb2_buffer 구초제(video memory)를 위한 메모리를 할당하여 내용을 채우고, 해당 버퍼를 q-&gt;bufs 배열에 삽입한다. 그리고 vb-&gt;planes[plane].length 크기만큼 메모리를 할당하여 vb-&gt;planes[plane].mem_priv 에 설정한다.</p>

<p>해당 버퍼의 state는 VB2_BUF_STATE_DEQUEUED 로 설정된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_queue_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                             <span class="k">enum</span> <span class="n">vb2_memory</span> <span class="n">memory</span><span class="p">,</span>                     <span class="c1">// VB2_MEMORY_MMAP</span>
                             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_buffers</span><span class="p">,</span>                   <span class="c1">// 2</span>
                             <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_planes</span><span class="p">,</span>                    <span class="c1">// 1</span>
                             <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">plane_sizes</span><span class="p">[</span><span class="n">VB2_MAX_PLANES</span><span class="p">])</span> <span class="c1">// plane_sizes[0] = size</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 버퍼 2개에 대해 vb2_buffer 구조체 메모리 할당</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">buf_struct_size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
        <span class="p">...</span>

        <span class="c1">// vb2_buffer 구조체 채우기</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">;</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span> <span class="o">=</span> <span class="n">q</span><span class="p">;</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span> <span class="o">=</span> <span class="n">num_planes</span><span class="p">;</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">+</span> <span class="n">buffer</span><span class="p">;</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">=</span> <span class="n">memory</span><span class="p">;</span>    <span class="c1">// VB2_MEMORY_MMAP</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span> <span class="o">=</span> <span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">];</span>
            <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">min_length</span> <span class="o">=</span> <span class="n">plane_sizes</span><span class="p">[</span><span class="n">plane</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">// queue-&gt;bufs 배열에 할당된 videovb2_bufferbuf 구조체 설정</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">vb</span><span class="p">;</span>

        <span class="c1">// 버퍼는 q-&gt;bufs[vb-&gt;indx] 에 할당됨</span>
        <span class="c1">// mmap 주소는 vb-&gt;planes[plane].mem_priv 에 설정됨</span>
        <span class="c1">// plane 1개에 buffer 2개인 상태임</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">memory</span> <span class="o">==</span> <span class="n">VB2_MEMORY_MMAP</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 전달된 버퍼에 대해 video memory(vb2_buffer) 할당</span>
            <span class="c1">// 할당된 메모리 주소는 vb-&gt;planes[plane].mem_priv 에 설정</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_buf_mem_alloc</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>
            <span class="p">...</span>
            
            <span class="c1">// vb-&gt;planes[plane].m.offset 에 vb-&gt;planes[plane].length 만큼 오프셋을 설정</span>
            <span class="n">__setup_offsets</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

            <span class="c1">// vb2_buffer 에 대해 Driver에서 제공하는 buf_init 함수 실행하여 추가적인 버퍼 초기화</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">call_vb_qop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">buf_init</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
            <span class="p">...</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34112-__vb2_buf_mem_alloc">3.4.1.1.2 __vb2_buf_mem_alloc()</h6>

<p>이 함수는 vb-&gt;planes[plane].length 변수에 저장된 크기만큼 메모리를 할당한 후 그 값을 vb-&gt;planes[plane].mem_priv 변수에 저장한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_buf_mem_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">length</span><span class="p">);</span>
        <span class="n">mem_priv</span> <span class="o">=</span> <span class="n">call_ptr_memop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">alloc</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">alloc_devs</span><span class="p">[</span><span class="n">plane</span><span class="p">]</span> <span class="o">?</span> <span class="o">:</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_attrs</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">dma_dir</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">gfp_flags</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span> <span class="o">=</span> <span class="n">mem_priv</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3412-vb2_core_qbuf">3.4.1.2 vb2_core_qbuf()</h5>

<p>이 함수는 먼저 __buf_prepare() -&gt; vid_cap_buf_prepare() 순서로 함수를 호출하여 전달된 버퍼의 type에 적절한 크기를 구해 vb-&gt;planes[plane_no].bytesused 에 설정하고, state를 VB2_BUF_STATE_PREPARED 로 변경한다.</p>

<p>이후 해당 버퍼의 vb-&gt;queued_entry를 q-&gt;queued_list 리스트에 추가하고, q-&gt;waiting_for_buffers 를 false 로 설정하여 해당 버퍼가 queueed_list에 추가되었음을 설정한 후, state 를 VB2_BUF_STATE_QUEUED 로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-core.c#L653</span>
<span class="kt">int</span> <span class="nf">vb2_core_qbuf</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>  <span class="c1">// 0 ~ 1</span>
                  <span class="kt">void</span> <span class="o">*</span><span class="n">pb</span><span class="p">)</span>            <span class="c1">// null</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>    <span class="c1">// 이전에 할당되어 q-&gt;bufs 배열에 저장되어 있던 vb2_buffer 버퍼</span>

    <span class="c1">// __vb2_queue_alloc() 함수에서 state는 VB2_BUF_STATE_DEQUEUED로 설정되어 있음</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// state를 VB2_BUF_STATE_PREPARING 로 변경, vb-&gt;planes[plane_no].bytesused = size 설정됨</span>
    <span class="k">case</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">__buf_prepare</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">pb</span><span class="p">);</span>	<span class="c1">// vbi_cap_buf_prepare() 함수 호출</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">}</span>

    <span class="c1">// vb-&gt;queued_entry 를 q-&gt;queued_list 에 삽입</span>
    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queued_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="o">++</span><span class="p">;</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">waiting_for_buffers</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// queue 에 추가되었음을 설정</span>

    <span class="c1">// state 를 VB2_BUF_STATE_QUEUED 로 변경</span>
    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_QUEUED</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34121-vid_cap_buf_prepare">3.4.1.2.1 vid_cap_buf_prepare()</h6>

<p>이 함수는 전달된 버퍼의 type에 맞는 크기를 vb-&gt;planes[plane_no].bytesused 에 설정하는 역할을 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vid_cap_buf_prepare</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="n">buffers</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">tpg_g_line_width</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">tpg</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span> <span class="o">*</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fmt_cap_rect</span><span class="p">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fmt_cap</span><span class="o">-&gt;</span><span class="n">data_offset</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
        <span class="p">...</span>
        <span class="n">vb2_set_plane_payload</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>     <span class="c1">// vb-&gt;planes[plane_no].bytesused = size</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">p</span><span class="p">].</span><span class="n">data_offset</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">fmt_cap</span><span class="o">-&gt;</span><span class="n">data_offset</span><span class="p">[</span><span class="n">p</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34122-__enqueue_in_driver">3.4.1.2.2 __enqueue_in_driver()</h6>

<p>이 함수는 state 를 VB2_BUF_STATE_ACTIVE 로 변경하고, vid_cap_buf_queue() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">__enqueue_in_driver</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
    <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_ACTIVE</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="c1">// vid_cap_buf_queue() 호출</span>
    <span class="n">call_void_vb_qop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">buf_queue</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34123-vid_cap_buf_queue">3.4.1.2.3 vid_cap_buf_queue()</h6>

<p>이 함수는 전달된 버퍼를 vivid_dev-&gt;vid_cap_active 리스트에 추가한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">vbi_cap_buf_queue</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// vivid_buffer 를 vivid_dev-&gt;vid_cap_active 리스트에 추가</span>
    <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3413-vb2_core_streamon">3.4.1.3 vb2_core_streamon()</h5>

<p>할당된 buffer가 vid_cap_active 에 추가되면 vb2_core_streamon() 함수가 호출되며, 이 함수는  다시vb2_start_streaming() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/v4l2-core/videobuf2-core.c#L1696</span>
<span class="kt">int</span> <span class="nf">vb2_core_streamon</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span> <span class="o">&gt;=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">min_buffers_needed</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">vb2_start_streaming</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34131-vb2_start_streaming">3.4.1.3.1 vb2_start_streaming()</h6>

<p>이 함수는 먼저 queued_list 에 있는 각 vb2_buffer를 __enqueue_in_driver() 함수 호출을 통해 vivid_dev-&gt;vid_cap_active 리스트에 추가한 후, streaming이 시작되었음을 설정한다. 그리고 start_streaming() 함수를 호출하는데 이 함수는 vid_cap_start_streaming() 함수와 연결되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-vbi-cap.c#L235</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">vb2_ops</span> <span class="n">vivid_vbi_cap_qops</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">queue_setup</span>	<span class="o">=</span> <span class="n">vbi_cap_queue_setup</span><span class="p">,</span>
    <span class="p">.</span><span class="n">buf_prepare</span>	<span class="o">=</span> <span class="n">vbi_cap_buf_prepare</span><span class="p">,</span>
    <span class="p">.</span><span class="n">buf_queue</span>		<span class="o">=</span> <span class="n">vbi_cap_buf_queue</span><span class="p">,</span>
    <span class="p">.</span><span class="n">start_streaming</span>	<span class="o">=</span> <span class="n">vbi_cap_start_streaming</span><span class="p">,</span>
    <span class="p">.</span><span class="n">stop_streaming</span>	<span class="o">=</span> <span class="n">vbi_cap_stop_streaming</span><span class="p">,</span>
    <span class="p">.</span><span class="n">wait_prepare</span>	<span class="o">=</span> <span class="n">vb2_ops_wait_prepare</span><span class="p">,</span>
    <span class="p">.</span><span class="n">wait_finish</span>	<span class="o">=</span> <span class="n">vb2_ops_wait_finish</span><span class="p">,</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">vb2_start_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// q-&gt;queued_list 에 들어있는 vb2_buffer를 vivid_dev-&gt;vid_cap_active 리스트에 추가</span>
    <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_list</span><span class="p">,</span> <span class="n">queued_entry</span><span class="p">)</span>
        <span class="n">__enqueue_in_driver</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

    <span class="c1">// 스트리밍 시작 설정</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">start_streaming_called</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// vid_cap_start_streaming() 호출</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">call_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">start_streaming</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">owned_by_drv_count</span><span class="p">));</span>
    <span class="c1">// start_streaming 이 정상적으로 종료되면 return</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34132-vid_cap_start_streaming">3.4.1.3.2 vid_cap_start_streaming()</h6>

<p>이 함수는 vivid_start_generating_vid_cap() 함수를 호출한다. 만약 에러가 발생할 경우 해당 버퍼를 vid_cap_active 리스트에서 제거하고 vb2_buffer_done() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">vid_cap_start_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">start_streaming_error</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">err</span> <span class="o">=</span> <span class="n">vivid_start_generating_vid_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_streaming</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
            <span class="n">vb2_buffer_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">,</span> <span class="n">VB2_BUF_STATE_QUEUED</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34133-vivid_start_generating_vid_cap">3.4.1.3.3 vivid_start_generating_vid_cap()</h6>

<p>이 함수는 kernel thread를 생성해 vivid_thread_vid_cap() 함수를 실행한다. 실행된 스레드는 lock을 획득할 때 까지 대기하다가, lock을 획득하면 vivid_thread_vid_cap_tick() 함수를 통해 데이터 저장을 시작한다. 여기서 lock에 사용되는 dev-&gt;mutex 는 dev-&gt;queue-&gt;vivid_dev-&gt;mutex 와 동일하다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-kthread-cap.c#L855</span>
<span class="kt">int</span> <span class="nf">vivid_start_generating_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vivid_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">pstreaming</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">vivid_thread_vid_cap</span><span class="p">,</span> <span class="n">dev</span><span class="p">,</span> <span class="s">"%s-vid-cap"</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">v4l2_dev</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="c1">// https://elixir.bootlin.com/linux/v4.15/source/drivers/media/platform/vivid/vivid-kthread-cap.c#L752</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">vivid_thread_vid_cap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>	<span class="c1">// lock(dev-&gt;queue-&gt;vivid_dev-&gt;mutex)</span>
        <span class="p">...</span>
        <span class="c1">// vivid_buffer vid_cap_buf 과 vbi_cap_buf 를 채운다.</span>
        <span class="n">vivid_thread_vid_cap_tick</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">dropped_bufs</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>	<span class="c1">// unlock(dev-&gt;queue-&gt;vivid_dev-&gt;mutex)</span>
        <span class="p">...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>위에서 생성된 kernel thread는 데이터를 저장하기 위해 vivid_dev-&gt;mutex의 lock을 획득하려고 시도한다. 하지만 이 mutex는 이미 vb2_fop_read() 함수에서 lock이 되어 있는 상태이므로 어디에선가 unlock이 될 때까지 계속 대기하게 된다.</p>
</blockquote>

<h6 id="34134-vivid_thread_vid_cap_tick">3.4.1.3.4 vivid_thread_vid_cap_tick()</h6>

<p>이 함수는 vivid_fillbuff() 함수를 호출하여 vid_cap_active 리스트로부터 얻어온 버퍼를 해당 리스트에서 삭제한 뒤 vivid_fillbuff() 함수를 호출하여 실제로 채우고 이 작업이 완료되면 vb2_buffer_done() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">vivid_thread_vid_cap_tick</span><span class="p">(</span><span class="k">struct</span> <span class="n">vivid_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dropped_bufs</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// dev-&gt;vid_cap_active 에서 vivid_buffer vid_cap_buf 1개 가져오고 리스트에서 제거</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">vid_cap_buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vivid_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vid_cap_buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vid_cap_buf</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vivid_fillbuff</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="n">vid_cap_buf</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="n">vb2_buffer_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vid_cap_buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dqbuf_error</span> <span class="o">?</span> <span class="n">VB2_BUF_STATE_ERROR</span> <span class="o">:</span> <span class="n">VB2_BUF_STATE_DONE</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34135-vb2_buffer_done">3.4.1.3.5 vb2_buffer_done()</h6>

<p>버퍼를 채우는 작업이 완료되면 호출되는 함수이다. 이 함수는 q-&gt;done_list에 해당 버퍼를 추가하고 wake_up() 함수를 호출하여 이벤트를 발생시킨다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vb2_buffer_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span><span class="p">,</span>
                     <span class="k">enum</span> <span class="n">vb2_buffer_state</span> <span class="n">state</span><span class="p">)</span>	<span class="c1">// VB2_BUF_STATE_DONE</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">vb2_queue</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>
    <span class="c1">// __enqueue_in_driver() 에서 VB2_BUF_STATE_ACTIVE 로 설정됨</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">WARN_ON</span><span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_ACTIVE</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_QUEUED</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_REQUEUEING</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span>
            <span class="n">call_void_memop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>	<span class="c1">// 잘 모르겠음</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">else</span> <span class="p">{</span>
        <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">done_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">);</span>	<span class="c1">// q-&gt;done_list 에 해당 버퍼를 추가함</span>
        <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>	<span class="c1">// state 는 VB2_BUF_STATE_DONE 로 변경</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="nl">default:</span>
        <span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">);</span>	<span class="c1">// 이벤트 발생</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 위에서 생성한 kernel thread는 lock을 획득할 때까지 대기하게 되고, 실행 흐름은 다시 __vb2_perform_fileio() 함수로 돌아와서 vb2_core_dqbuf() 함수가 실행된다. 이 부분은 앞에서 살펴본 DQBUF에 해당한다.</p>

<h4 id="342-vb2_core_dqbuf">3.4.2 vb2_core_dqbuf()</h4>

<p>이 함수는 __vb2_get_done_vb() 함수를 호출해 kernel thread 가 삽입한 버퍼를 q-&gt;done_list 로부터 가져와 vb2_buffer 구조체 변수에 저장한다. 그리고 vid_cap_buf_finish() 함수를 호출하여 time code를 설정한 후 해당 버퍼를 queued_entry 로부터 제거하고 state를 VB2_BUF_STATE_DEQUEUED로 변경한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vb2_core_dqbuf</span><span class="p">(</span> <span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">pindex</span><span class="p">,</span>   <span class="c1">// 2</span>
                    <span class="kt">void</span> <span class="o">*</span><span class="n">pb</span><span class="p">,</span>               <span class="c1">// null</span>
                    <span class="n">bool</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_get_done_vb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vb</span><span class="p">,</span> <span class="n">pb</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>	<span class="c1">// VB2_BUF_STATE_DONE</span>
    <span class="k">case</span> <span class="n">VB2_BUF_STATE_DONE</span><span class="p">:</span>
        <span class="n">dprintk</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">"returning done buffer</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
    <span class="p">}</span>

    <span class="n">call_void_vb_qop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">buf_finish</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>	<span class="c1">// vid_cap_buf_finish() 호출, 타임코드 설정</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pindex</span><span class="p">)</span>
        <span class="o">*</span><span class="n">pindex</span> <span class="o">=</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>

    <span class="c1">// pb 가 null 이므로 호출되지 않음</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pb</span><span class="p">)</span>
        <span class="n">call_void_bufop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fill_user_buffer</span><span class="p">,</span> <span class="n">vb</span><span class="p">,</span> <span class="n">pb</span><span class="p">);</span>

    <span class="c1">// 해당 버퍼를 queued_entry 에서 제거한다</span>
    <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">queued_entry</span><span class="p">);</span>
    <span class="n">q</span><span class="o">-&gt;</span><span class="n">queued_count</span><span class="o">--</span><span class="p">;</span>

    <span class="n">trace_vb2_dqbuf</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>	

    <span class="c1">// state 를 VB2_BUF_STATE_DEQUEUED 로 변경</span>
    <span class="n">__vb2_dqbuf</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="3421-__vb2_get_done_vb">3.4.2.1 __vb2_get_done_vb()</h5>

<p>이 함수는 __vb2_wait_for_done_vb()를 호출하여 사용 가능한 버퍼가 있을 때까지 대기하다가 q-&gt;done_list 로부터 버퍼를 획득한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_get_done_vb</span><span class="p">(</span>   <span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
                                <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">**</span><span class="n">vb</span><span class="p">,</span> <span class="c1">// NULL, __out, get buffer from q-&gt;done_list</span>
                                <span class="kt">void</span> <span class="o">*</span><span class="n">pb</span><span class="p">,</span>   <span class="c1">// null</span>
                                <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 버퍼를 사용할 수 있을 때까지 대기함</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_wait_for_done_vb</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">nonblocking</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="c1">// done_list 로부터 버퍼 획득</span>
    <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vb2_buffer</span><span class="p">,</span> <span class="n">done_entry</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="34211-__vb2_wait_for_done_vb">3.4.2.1.1 __vb2_wait_for_done_vb()</h6>

<p>이 함수는 unlock 후 wait_event_interruptible() 함수를 호출하여 해당 버퍼를 사용할 수 있을 때까지 대기한 후 다시 lock을 한다. 해당 함수가 대기하는 q-&gt;done_wq  는 kernel thread 가 lock을 획득하여 버퍼를 채운 후 호출하는 vb2_buffer_done() 함수에서 발생시키는 이벤트이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_wait_for_done_vb</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nonblocking</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">call_void_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_prepare</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>  <span class="c1">// mutex_unlock(vq-&gt;lock);</span>
        
        <span class="c1">// wake_up 이 되면 condition 체크 후 만족하지 않으면 다시 sleep</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">,</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">streaming</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>

        <span class="n">call_void_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">wait_finish</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>   <span class="c1">// mutex_lock(vq-&gt;lock);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="343-copy_to_user">3.4.3 copy_to_user()</h4>

<p>이제 버퍼에 저장된 내용을 사용자 영역으로 복사한다.</p>

<h3 id="4-close-과정-소스-분석">4. CLOSE 과정 소스 분석</h3>

<p>close()는 vivid_fop_release() 함수로부터 시작한다.</p>

<h4 id="41-vivid_fop_release">4.1 vivid_fop_release()</h4>

<p>vb2_fop_release() 함수를 호출한다. 내부적으로 vb2_fop_release() 함수를 호출하며, 내부에서 다시 _vb2_fop_release() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vb2_fop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">video_device</span> <span class="o">*</span><span class="n">vdev</span> <span class="o">=</span> <span class="n">video_devdata</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">?</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">lock</span> <span class="o">:</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">;</span>	<span class="c1">// vdev-&gt;queue-&gt;lock == vdev-&gt;lock</span>
    <span class="k">return</span> <span class="n">_vb2_fop_release</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">vivid_fop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vb2_fop_release</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="42-_vb2_fop_release">4.2 _vb2_fop_release</h4>

<p>이 함수는 파라미터로 전달된 lock 변수에 mutex_lock() 을 걸고 vb2_queue_release() 함수를 호출한다. 해당 함수는 다시 vb2_core_queue_release() 함수를 호출하며, 해당 함수가 완료되면 획득한 lock을 다시 unlock  한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vb2_queue_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">vb2_core_queue_release</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_vb2_fop_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>	<span class="c1">// lock(vdev-&gt;queue-&gt;lock) == lock(vivid_dev-&gt;mutex)</span>
        <span class="n">mutex_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">==</span> <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vb2_queue_release</span><span class="p">(</span><span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
        <span class="n">vdev</span><span class="o">-&gt;</span><span class="n">queue</span><span class="o">-&gt;</span><span class="n">owner</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">mutex_unlock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="43-vb2_core_queue_release">4.3 vb2_core_queue_release()</h4>

<p>이 함수는 아래와 같이 세 부분으로 이루어져 있다.</p>

<ol>
  <li>__vb2_cleanup_fileio()</li>
  <li>vb2_queue_cancel()</li>
  <li>__vb2_queue_free()</li>
</ol>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vb2_core_queue_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__vb2_cleanup_fileio</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>	<span class="c1">// fileio 관련 리소스 해제, wake_up_all(&amp;q-&gt;done_wq);</span>
    <span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mmap_lock</span><span class="p">);</span>	<span class="c1">// lock(vdev-&gt;queue-&gt;lock) == lock(vivid_dev-&gt;mutex)</span>
    <span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">);</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">mmap_lock</span><span class="p">);</span>	<span class="c1">// unlock(vdev-&gt;queue-&gt;lock) == lock(vivid_dev-&gt;mutex)</span>
<span class="p">}</span>
</code></pre></div></div>

<h5 id="431-__vb2_cleanup_fileio">4.3.1 __vb2_cleanup_fileio()</h5>

<p>이 함수는 fileio 에서 사용되었던 리소스들을 해제하는 역할을 한다. 먼저 vb2_core_streamoff() -&gt; __vb2_queue_cancel() 함수를 호출하여, streaming을 일시 중지하고 드라이버와 videobuf에서 모든 버퍼를 제거한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">vb2_core_streamoff</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_cleanup_fileio</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fileio</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vb2_core_streamoff</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">);</span>
        <span class="p">...</span>
        <span class="n">vb2_core_reqbufs</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">fileio</span><span class="o">-&gt;</span><span class="n">memory</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileio</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">fileio</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="4311-__vb2_queue_cancel">4.3.1.1 __vb2_queue_cancel()</h6>

<p>이 함수는 vid_cap_stop_streaming() -&gt; vivid_stop_generating_vid_cap() 함수를 차례대로 호출하여 vid_cap_active 리스트 내 모든 버퍼들을 해당 리스트에서 제거하고 vb2_buffer_done() 함수를 호출하여 해당 버퍼를 done_list에 추가한다. 그리고 kthread_stop() 함수를 호출한다.</p>

<p>위의 작업이 완료되면 q-&gt;done_wq 이벤트를 발생시키고 모든 버퍼들에 대해 vid_cap_buf_finish() 함수 및 __vb2_dqbuf() 함수를 호출한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="nf">vid_cap_stop_streaming</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">vq</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">vivid_stop_generating_vid_cap</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_streaming</span><span class="p">);</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__vb2_queue_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// 이 값은 vb2_start_streaming() 함수에서 1로 설정된 상태이다.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">start_streaming_called</span><span class="p">)</span>
        <span class="n">call_void_qop</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">stop_streaming</span><span class="p">,</span> <span class="n">q</span><span class="p">);</span>	<span class="c1">// vid_cap_stop_streaming() 호출</span>
    <span class="p">...</span>	
    <span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">done_wq</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">vb2_buffer</span> <span class="o">*</span><span class="n">vb</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VB2_BUF_STATE_PREPARED</span> <span class="o">||</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">VB2_BUF_STATE_QUEUED</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">plane</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">plane</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">plane</span> <span class="o">&lt;</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">num_planes</span><span class="p">;</span> <span class="o">++</span><span class="n">plane</span><span class="p">)</span>
              <span class="n">call_void_memop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">finish</span><span class="p">,</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="n">plane</span><span class="p">].</span><span class="n">mem_priv</span><span class="p">);</span>	<span class="c1">// vid_cap_buf_finish() 호출, 타임코드 설정</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">VB2_BUF_STATE_DEQUEUED</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">vb</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">VB2_BUF_STATE_PREPARED</span><span class="p">;</span>
            <span class="n">call_void_vb_qop</span><span class="p">(</span><span class="n">vb</span><span class="p">,</span> <span class="n">buf_finish</span><span class="p">,</span> <span class="n">vb</span><span class="p">);</span>	<span class="c1">// vid_cap_buf_finish() 호출, 타임코드 설정</span>
        <span class="p">}</span>
        <span class="n">__vb2_dqbuf</span><span class="p">(</span><span class="n">vb</span><span class="p">);</span>	<span class="c1">// state 를 VB2_BUF_STATE_DEQUEUED 로 변경</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="43111-vivid_stop_generating_vid_cap">4.3.1.1.1 vivid_stop_generating_vid_cap()</h6>

<p>이 함수는 vid_cap_active 리스트로부터 모든 버퍼들을 제거하고, vb2_buffer_done() 함수를 호출하여 done_list에 추가한다. 모든 버퍼에 대해 위의 작업이 완료되면, unlock 후 kthread_stop() 함수를 호출해 kernel thread 가 실행 중이던 vivid_thread_vid_cap() 함수를 종료하고 다시 lock을 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">vivid_stop_generating_vid_cap</span><span class="p">(</span><span class="k">struct</span> <span class="n">vivid_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">pstreaming</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pstreaming</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_streaming</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Release all active buffers */</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">struct</span> <span class="n">vivid_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">vid_cap_active</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vivid_buffer</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
            <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
            <span class="n">vb2_buffer_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">,</span> <span class="n">VB2_BUF_STATE_ERROR</span><span class="p">);</span>
            <span class="n">dprintk</span><span class="p">(</span><span class="n">dev</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s">"vid_cap buffer %d done</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">vb</span><span class="p">.</span><span class="n">vb2_buf</span><span class="p">.</span><span class="n">index</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="p">...</span>
    <span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">kthread_stop</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span><span class="p">);</span>
    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">kthread_vid_cap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h6 id="4312-vb2_core_reqbufs">4.3.1.2 vb2_core_reqbufs()</h6>

<p>close 될 때의 이 함수는 아래 if 문을 실행하게 되는데, 이 함수 호출 전에 실행된 __vb2_queue_cancel() 함수를 한번 더 실행한 후 __vb2_queue_free() 함수를 실행하여 해당 버퍼의 vb-&gt;planes[plane].mem_priv 메모리와 videobuf 메모리를 해제한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span> <span class="nf">__vb2_queue_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffers</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">__vb2_free_mem</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">buffers</span><span class="p">);</span>
    <span class="p">...</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">-</span> <span class="n">buffers</span><span class="p">;</span> <span class="n">buffer</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">;</span> <span class="o">++</span><span class="n">buffer</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">kfree</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]);</span>
        <span class="n">q</span><span class="o">-&gt;</span><span class="n">bufs</span><span class="p">[</span><span class="n">buffer</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">vb2_core_reqbufs</span><span class="p">(</span><span class="k">struct</span> <span class="n">vb2_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">enum</span> <span class="n">vb2_memory</span> <span class="n">memory</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">memory</span> <span class="o">!=</span> <span class="n">memory</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">__vb2_queue_cancel</span><span class="p">(</span><span class="n">q</span><span class="p">);</span>	<span class="c1">// 혹시 모를 PREPARED 또는 QUEUED 상태 버퍼 정리</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">__vb2_queue_free</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">num_buffers</span><span class="p">);</span>
        <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<h4 id="432-__vb2_queue_cancel">4.3.2 __vb2_queue_cancel()</h4>

<p>__vb2_cleanup_fileio() 함수에서 에러가 발생했을 경우를 대비하여 한번 더 호출하는 것으로 보인다.</p>

<h4 id="433-__vb2_queue_free">4.3.3 __vb2_queue_free()</h4>

<p>__vb2_cleanup_fileio() 함수에서 에러가 발생했을 경우를 대비하여 한번 더 호출하는 것으로 보인다.</p>

<h3 id="5-취약점-분석">5. 취약점 분석</h3>

<p>위에서 소스를 분석한 결과를 보면 개발자가 원래 의도했던 기능을 위한 함수 호출 순서는 다음이었던 것으로 보인다. (소스로만 분석한 거라 실제 실행 순서와는 차이가 있을 수 있음)</p>

<p><strong>Read</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Function</th>
      <th style="text-align: center">Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">vb2_fop_read</td>
      <td style="text-align: center">lock</td>
    </tr>
    <tr>
      <td style="text-align: center">vb2_start_streaming</td>
      <td style="text-align: center">add buffer</td>
    </tr>
    <tr>
      <td style="text-align: center">vb2_core_dqbuf</td>
      <td style="text-align: center">unlock</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_thread_vid_cap</td>
      <td style="text-align: center">lock</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_thread_vid_cap_tick</td>
      <td style="text-align: center">remove buffer</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_thread_vid_cap</td>
      <td style="text-align: center">unlock</td>
    </tr>
    <tr>
      <td style="text-align: center">vb2_core_dqbuf</td>
      <td style="text-align: center">lock</td>
    </tr>
    <tr>
      <td style="text-align: center">vb2_fop_read</td>
      <td style="text-align: center">unlock</td>
    </tr>
  </tbody>
</table>

<p><br />
<a href="/assets/images/cve-2019-18683/vivid_read.png"><img src="/assets/images/cve-2019-18683/vivid_read.png" alt="vivid_read" style="zoom:70%;" /></a></p>

<p><br />
<strong>Close</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Function</th>
      <th style="text-align: center">Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">_vb2_fop_release</td>
      <td style="text-align: center">lock</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_stop_generating_vid_cap</td>
      <td style="text-align: center">remove buffer</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_stop_generating_vid_cap</td>
      <td style="text-align: center">unlock</td>
    </tr>
    <tr>
      <td style="text-align: center">vivid_stop_generating_vid_cap</td>
      <td style="text-align: center">lock</td>
    </tr>
    <tr>
      <td style="text-align: center">vb2_core_reqbufs</td>
      <td style="text-align: center">release buffer memory</td>
    </tr>
    <tr>
      <td style="text-align: center">_vb2_fop_release</td>
      <td style="text-align: center">unlock</td>
    </tr>
  </tbody>
</table>

<p><br />
<a href="/assets/images/cve-2019-18683/vivid_close.png"><img src="/assets/images/cve-2019-18683/vivid_close.png" alt="vivid_close" style="zoom:70%;" /></a></p>

<p><br />
위의 그림에서 볼 수 있듯이 open과 close는 모두 동일한 mutex를 바라보고 동기화를 수행한다. 따라서 multi processor 환경에서 동시에 open과 close를 반복하게 될 경우 race condition이 발생하게 된다.</p>

<p>아래는 원문 저자가 올린 <a href="https://a13xp0p0v.github.io/img/v4l2-crasher.c">poc</a> 코드를 실행했을 때 crash가 일어나기 전까지 출력된 결과이다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPUID | Function | Action | Caller
0 [vb2_fop_read] (lock), caller:(v4l2_read+0x71/0x90)&lt;/div&gt;
0 [vb2_core_reqbufs], caller:(__vb2_init_fileio+0xfe/0x2c0)
0 [__vb2_queue_alloc] (alloc buffer) vb:0000000031fe575c, caller:(vb2_core_reqbufs+0x197/0x400)
0 [__vb2_buf_mem_alloc] (alloc mem_priv) mem_priv:000000004bcd5f2e, caller:(vb2_core_reqbufs+0x197/0x400)
0 [__vb2_queue_alloc] (alloc buffer) vb:0000000060c02281, caller:(vb2_core_reqbufs+0x197/0x400)
0 [__vb2_buf_mem_alloc] (alloc mem_priv) mem_priv:00000000e61115ec, caller:(vb2_core_reqbufs+0x197/0x400)
0 [vb2_core_qbuf] (add queued_list) vb:0000000031fe575c, caller:(__vb2_init_fileio+0x253/0x2c0)
0 [vb2_core_qbuf] (add queued_list) vb:0000000060c02281, caller:(__vb2_init_fileio+0x253/0x2c0)
0 [__enqueue_in_driver] caller:(vb2_start_streaming+0x33/0xd0) 
0 [vid_cap_buf_queue] (add vid_cap_active) vb:0000000031fe575c, caller:(__enqueue_in_driver+0x65/0xb0)
0 [__enqueue_in_driver] caller:(vb2_start_streaming+0x33/0xd0) 
0 [vid_cap_buf_queue] (add vid_cap_active) vb:0000000060c02281, caller:(__enqueue_in_driver+0x65/0xb0)
0 [vid_cap_start_streaming], caller:(vb2_start_streaming+0x6d/0xd0)
0 [vivid_start_generating_vid_cap], caller:(vid_cap_start_streaming+0x163/0x180)
0 [__vb2_wait_for_done_vb] (unlock), caller:(__vb2_perform_fileio+0x294/0x410)
0 [vivid_thread_vid_cap] (lock), caller:(kthread+0x122/0x140)
0 [vivid_thread_vid_cap_tick], caller:(kthread+0x122/0x140)
0 [vivid_fillbuff] (fill buffer) buf:0000000031fe575c, caller:(vivid_thread_vid_cap+0x2f2/0x850)
1 [vb2_fop_read] caller:(v4l2_read+0x71/0x90) 
0 [vb2_buffer_done], caller:(vivid_thread_vid_cap+0x33d/0x850)
0 [vb2_buffer_done] (add done_list) vb:0000000031fe575c, caller:(vivid_thread_vid_cap+0x33d/0x850)
0 [vivid_thread_vid_cap] (unlock), caller:(kthread+0x122/0x140)
1 [vb2_fop_read] (lock), caller:(v4l2_read+0x71/0x90)
1 [__vb2_perform_fileio], caller:(vb2_read+0x14/0x20)
1 [__vb2_get_done_vb] (remove q-&gt;done_list) vb:00000000607e3ca1, caller:(__vb2_perform_fileio+0x294/0x410)
1 [__vb2_dqbuf], caller:(vb2_core_dqbuf+0x20f/0x630)
1 [vb2_core_qbuf] (add queued_list) vb:0000000031fe575c, caller:(__vb2_perform_fileio+0x18a/0x410)
1 [__enqueue_in_driver] caller:(vb2_core_qbuf+0x1b4/0x1e0) 
1 [vid_cap_buf_queue] (add vid_cap_active) vb:0000000031fe575c, caller:(__enqueue_in_driver+0x65/0xb0)
1 [vb2_fop_read] (unlock), caller:(v4l2_read+0x71/0x90)
0 [__vb2_wait_for_done_vb] (lock), caller:(__vb2_perform_fileio+0x294/0x410)
0 [__vb2_wait_for_done_vb] (unlock), caller:(__vb2_perform_fileio+0x294/0x410)
1 [vb2_fop_release], caller:(vivid_fop_release+0x8d/0x1c0)
1 [_vb2_fop_release] (lock), caller:(vb2_fop_release+0x4c/0x70)
1 [vb2_core_queue_release], caller:(_vb2_fop_release+0xd3/0xf0)
1 [__vb2_cleanup_fileio], caller:(vb2_core_queue_release+0x3b/0x70)
1 [vb2_core_streamoff], caller:(__vb2_cleanup_fileio+0x4f/0xb0)
1 [__vb2_queue_cancel], caller:(vb2_core_streamoff+0x3d/0x90)
1 [vid_cap_stop_streaming], caller:(__vb2_queue_cancel+0x4d/0x120)
1 [vivid_stop_generating_vid_cap] remove vid_cap_active vb:0000000060c02281, caller:(vid_cap_stop_streaming+0x4c/0x60)
1 [vb2_buffer_done], caller:(vivid_stop_generating_vid_cap+0x15d/0x200)
1 [vb2_buffer_done] (add done_list) vb:0000000060c02281, caller:(vivid_stop_generating_vid_cap+0x15d/0x200)
1 [vivid_stop_generating_vid_cap] remove vid_cap_active vb:0000000031fe575c, caller:(vid_cap_stop_streaming+0x4c/0x60)
1 [vb2_buffer_done], caller:(vivid_stop_generating_vid_cap+0x15d/0x200)
1 [vb2_buffer_done] (add done_list) vb:0000000031fe575c, caller:(vivid_stop_generating_vid_cap+0x15d/0x200)
1 [vivid_stop_generating_vid_cap] (unlock), caller:(vid_cap_stop_streaming+0x4c/0x60)
0 [__vb2_wait_for_done_vb] (lock), caller:(__vb2_perform_fileio+0x294/0x410)
0 [__vb2_get_done_vb] (remove q-&gt;done_list) vb:000000002d2e911c, caller:(__vb2_perform_fileio+0x294/0x410)
0 [__vb2_dqbuf], caller:(vb2_core_dqbuf+0x20f/0x630)
0 [vb2_core_qbuf] (add queued_list) vb:0000000060c02281, caller:(__vb2_perform_fileio+0x18a/0x410)
0 [__enqueue_in_driver] caller:(vb2_core_qbuf+0x1b4/0x1e0) 
0 [vid_cap_buf_queue] (add vid_cap_active) vb:0000000060c02281, caller:(__enqueue_in_driver+0x65/0xb0)
0 [vb2_fop_read] (unlock), caller:(v4l2_read+0x71/0x90)
1 [vivid_stop_generating_vid_cap] (lock), caller:(vid_cap_stop_streaming+0x4c/0x60)
1 [vb2_buffer_done], caller:(__vb2_queue_cancel.cold+0x63/0x65)
1 [vb2_buffer_done] (add done_list) vb:0000000060c02281, caller:(__vb2_queue_cancel.cold+0x63/0x65)
1 [__vb2_dqbuf], caller:(__vb2_queue_cancel+0x107/0x120)
1 [__vb2_dqbuf], caller:(__vb2_queue_cancel+0x107/0x120)
1 [vb2_core_reqbufs], caller:(__vb2_cleanup_fileio+0x72/0xb0)
1 [__vb2_queue_cancel], caller:(vb2_core_reqbufs+0xbd/0x400)
1 [__vb2_dqbuf], caller:(__vb2_queue_cancel+0x107/0x120)
1 [__vb2_dqbuf], caller:(__vb2_queue_cancel+0x107/0x120)
1 [__vb2_queue_free], caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_queue_free] (clean mem_priv) mem_priv:000000004bcd5f2e, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_queue_free] (clean mem_priv) mem_priv:00000000e61115ec, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_free_mem] (__vb2_buf_mem_free buffers) buffer:0000000031fe575c, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_buf_mem_free] (null to mem_priv) mem_priv:000000004bcd5f2e, caller:(__vb2_queue_free+0x295/0x2b0)
1 [__vb2_free_mem] (__vb2_buf_mem_free buffers) buffer:0000000060c02281, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_buf_mem_free] (null to mem_priv) mem_priv:00000000e61115ec, caller:(__vb2_queue_free+0x295/0x2b0)
1 [__vb2_queue_free] (kfree) buffer:0000000031fe575c, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_queue_free] (kfree) buffer:0000000060c02281, caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_cleanup_fileio] (kfree), caller:(vb2_core_queue_release+0x3b/0x70)
1 [__vb2_queue_cancel], caller:(vb2_core_queue_release+0x43/0x70)
1 [__vb2_queue_free], caller:(vb2_core_queue_release+0x5b/0x70)
1 [_vb2_fop_release] (unlock), caller:(vb2_fop_release+0x4c/0x70)
0 [vb2_fop_release], caller:(vivid_fop_release+0x8d/0x1c0)
1 [vb2_fop_read] caller:(v4l2_read+0x71/0x90) 
0 [_vb2_fop_release] (lock), caller:(vb2_fop_release+0x4c/0x70)
0 [_vb2_fop_release] (unlock), caller:(vb2_fop_release+0x4c/0x70)
1 [vb2_fop_read] (lock), caller:(v4l2_read+0x71/0x90)
0 [vb2_fop_read] caller:(v4l2_read+0x71/0x90) 
1 [__vb2_perform_fileio], caller:(vb2_read+0x14/0x20)
1 [__vb2_init_fileio], caller:(__vb2_perform_fileio+0x373/0x410)
1 [vb2_core_reqbufs], caller:(__vb2_init_fileio+0xfe/0x2c0)
1 [__vb2_queue_cancel], caller:(vb2_core_reqbufs+0xbd/0x400)
1 [__vb2_queue_free], caller:(vb2_core_reqbufs+0xcd/0x400)
1 [__vb2_queue_alloc] (alloc buffer) vb:000000006503affd, caller:(vb2_core_reqbufs+0x197/0x400)
1 [__vb2_buf_mem_alloc] (alloc mem_priv) mem_priv:00000000e61115ec, caller:(vb2_core_reqbufs+0x197/0x400)
1 [__vb2_queue_alloc] (alloc buffer) vb:00000000786bfc16, caller:(vb2_core_reqbufs+0x197/0x400)
1 [__vb2_buf_mem_alloc] (alloc mem_priv) mem_priv:000000006a469467, caller:(vb2_core_reqbufs+0x197/0x400)
1 [vb2_core_qbuf] (add queued_list) vb:000000006503affd, caller:(__vb2_init_fileio+0x253/0x2c0)
1 [vb2_core_qbuf] (add queued_list) vb:00000000786bfc16, caller:(__vb2_init_fileio+0x253/0x2c0)
1 [__enqueue_in_driver] caller:(vb2_start_streaming+0x33/0xd0) 
1 [vid_cap_buf_queue] (add vid_cap_active) vb:000000006503affd, caller:(__enqueue_in_driver+0x65/0xb0)
1 [__enqueue_in_driver] caller:(vb2_start_streaming+0x33/0xd0) 
1 [vid_cap_buf_queue] (add vid_cap_active) vb:00000000786bfc16, caller:(__enqueue_in_driver+0x65/0xb0)
1 [vid_cap_start_streaming], caller:(vb2_start_streaming+0x6d/0xd0)
1 [vivid_start_generating_vid_cap], caller:(vid_cap_start_streaming+0x163/0x180)
1 [__vb2_wait_for_done_vb] (unlock), caller:(__vb2_perform_fileio+0x294/0x410)
0 [vb2_fop_read] (lock), caller:(v4l2_read+0x71/0x90)
0 [__vb2_perform_fileio], caller:(vb2_read+0x14/0x20)
0 [__vb2_wait_for_done_vb] (unlock), caller:(__vb2_perform_fileio+0x294/0x410)
1 [vivid_thread_vid_cap] (lock), caller:(kthread+0x122/0x140)
1 [vivid_thread_vid_cap_tick], caller:(kthread+0x122/0x140)
1 [vivid_fillbuff] (fill buffer) buf:0000000060c02281, caller:(vivid_thread_vid_cap+0x2f2/0x850)
</code></pre></div></div>

<p><br />
아래는 위의 출력 결과를 조금 더 가독성 높게 정리한 결과이다. CPU 0과 1 두 개가 동시에 open(), close()를 실행하면서 수행될 때 호출되는 함수들의 call graph 를 나타낸 것이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">CPU</span> <span class="mi">0</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">vb2_read</span>
        <span class="n">__vb2_perform_fileio</span>
            <span class="n">__vb2_init_fileio</span>
                <span class="n">vb2_core_reqbufs</span>
                    <span class="n">__vb2_queue_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                    <span class="n">__vb2_buf_mem_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mo">000000004</span><span class="n">bcd5f2e</span>
                    <span class="n">__vb2_queue_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                    <span class="n">__vb2_buf_mem_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mf">00000000e61115</span><span class="n">ec</span>
            <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
            <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
            <span class="n">vb2_core_streamon</span>
                <span class="n">vb2_start_streaming</span>
                    <span class="n">__enqueue_in_driver</span>
                        <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                    <span class="n">__enqueue_in_driver</span>
                        <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                    <span class="n">vid_cap_start_streaming</span>
                        <span class="n">vivid_start_generating_vid_cap</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
                            <span class="n">vivid_thread_vid_cap</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
                                <span class="n">vivid_thread_vid_cap_tick</span>
                                    <span class="n">vivid_fillbuff</span> <span class="p">(</span><span class="n">fill</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">buf</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                                    <span class="n">vb2_buffer_done</span> <span class="p">(</span><span class="n">add</span> <span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                            <span class="n">vivid_thread_vid_cap</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 
 
<span class="n">CPU</span> <span class="mi">1</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">vb2_read</span>
        <span class="n">__vb2_perform_fileio</span>
            <span class="n">__vb2_get_done_vb</span> <span class="p">(</span><span class="n">remove</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mf">00000000607e3</span><span class="n">ca1</span>
            <span class="n">vb2_core_dqbuf</span>
                <span class="n">__vb2_dqbuf</span>
            <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                <span class="n">__enqueue_in_driver</span>
                    <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>


<span class="n">CPU</span> <span class="mi">0</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>


<span class="n">CPU</span> <span class="mi">1</span> <span class="p">(</span><span class="n">CLOSE</span><span class="p">)</span>
<span class="n">vb2_fop_release</span>
    <span class="n">_vb2_fop_release</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
        <span class="n">vb2_core_queue_release</span>
            <span class="n">__vb2_cleanup_fileio</span>
                <span class="n">vb2_core_streamoff</span>
                    <span class="n">__vb2_queue_cancel</span>
                        <span class="n">vid_cap_stop_streaming</span>
                            <span class="n">vivid_stop_generating_vid_cap</span> <span class="p">(</span><span class="n">remove</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                                <span class="n">vb2_buffer_done</span> <span class="p">(</span><span class="n">add</span> <span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                            <span class="n">vivid_stop_generating_vid_cap</span> <span class="p">(</span><span class="n">remove</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                                <span class="n">vb2_buffer_done</span> <span class="p">(</span><span class="n">add</span> <span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                            <span class="n">vivid_stop_generating_vid_cap</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 
 
<span class="n">CPU</span> <span class="mi">0</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
            <span class="n">__vb2_get_done_vb</span> <span class="p">(</span><span class="n">remove</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000002</span><span class="n">d2e911c</span>
            <span class="n">vb2_core_dqbuf</span>
                <span class="n">__vb2_dqbuf</span>
            <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                <span class="n">__enqueue_in_driver</span>
                    <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 
 
<span class="n">CPU</span> <span class="mi">1</span> <span class="p">(</span><span class="n">CLOSE</span><span class="p">)</span>
                            <span class="n">vivid_stop_generating_vid_cap</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
                        <span class="n">vb2_buffer_done</span> <span class="p">(</span><span class="n">add</span> <span class="n">done_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                        <span class="n">__vb2_dqbuf</span>
                        <span class="n">__vb2_dqbuf</span>
                <span class="n">vb2_core_reqbufs</span>
                    <span class="n">__vb2_queue_cancel</span>
                        <span class="n">__vb2_dqbuf</span>
                        <span class="n">__vb2_dqbuf</span>
                    <span class="n">__vb2_queue_free</span> <span class="p">(</span><span class="n">clean</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mem_priv</span><span class="o">:</span><span class="mo">000000004</span><span class="n">bcd5f2e</span>
                    <span class="n">__vb2_queue_free</span> <span class="p">(</span><span class="n">clean</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">vb</span><span class="o">-&gt;</span><span class="n">planes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mem_priv</span><span class="o">:</span><span class="mf">00000000e61115</span><span class="n">ec</span>
                    <span class="n">__vb2_free_mem</span> <span class="p">(</span><span class="n">__vb2_buf_mem_free</span> <span class="n">buffers</span><span class="p">)</span> <span class="n">buffer</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                        <span class="n">__vb2_buf_mem_free</span> <span class="p">(</span><span class="n">null</span> <span class="n">to</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mo">000000004</span><span class="n">bcd5f2e</span>
                    <span class="n">__vb2_free_mem</span> <span class="p">(</span><span class="n">__vb2_buf_mem_free</span> <span class="n">buffers</span><span class="p">)</span> <span class="n">buffer</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
                        <span class="n">__vb2_buf_mem_free</span> <span class="p">(</span><span class="n">null</span> <span class="n">to</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mf">00000000e61115</span><span class="n">ec</span>
                    <span class="n">__vb2_queue_free</span> <span class="p">(</span><span class="n">kfree</span><span class="p">)</span> <span class="n">buffer</span><span class="o">:</span><span class="mo">0000000031</span><span class="n">fe575c</span>
                    <span class="n">__vb2_queue_free</span> <span class="p">(</span><span class="n">kfree</span><span class="p">)</span> <span class="n">buffer</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
            <span class="n">__vb2_cleanup_fileio</span> <span class="p">(</span><span class="n">kfree</span><span class="p">)</span>
            <span class="n">__vb2_queue_cancel</span>
            <span class="n">__vb2_queue_free</span>
    <span class="n">_vb2_fop_release</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>

<span class="n">CPU</span> <span class="mi">0</span> <span class="p">(</span><span class="n">CLOSE</span><span class="p">)</span>
<span class="n">vb2_fop_release</span>
    <span class="n">_vb2_fop_release</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">_vb2_fop_release</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 

<span class="n">CPU</span> <span class="mi">1</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">vb2_read</span>
        <span class="n">__vb2_perform_fileio</span>
            <span class="n">__vb2_init_fileio</span>
                <span class="n">vb2_core_reqbufs</span>
                    <span class="n">__vb2_queue_cancel</span>
                    <span class="n">__vb2_queue_free</span>
                    <span class="n">__vb2_queue_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000006503</span><span class="n">affd</span>
                    <span class="n">__vb2_buf_mem_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mf">00000000e61115</span><span class="n">ec</span>
                    <span class="n">__vb2_queue_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000007</span><span class="mi">86</span><span class="n">bfc16</span>
                    <span class="n">__vb2_buf_mem_alloc</span> <span class="p">(</span><span class="n">alloc</span> <span class="n">mem_priv</span><span class="p">)</span> <span class="n">mem_priv</span><span class="o">:</span><span class="mo">000000006</span><span class="n">a469467</span>
                <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000006503</span><span class="n">affd</span>
                <span class="n">vb2_core_qbuf</span> <span class="p">(</span><span class="n">add</span> <span class="n">queued_list</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000007</span><span class="mi">86</span><span class="n">bfc16</span>
            <span class="n">vb2_core_streamon</span>
                <span class="n">vb2_start_streaming</span>
                    <span class="n">__enqueue_in_driver</span>
                        <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000006503</span><span class="n">affd</span>
                    <span class="n">__enqueue_in_driver</span>
                        <span class="n">vid_cap_buf_queue</span> <span class="p">(</span><span class="n">add</span> <span class="n">vid_cap_active</span><span class="p">)</span> <span class="n">vb</span><span class="o">:</span><span class="mo">000000007</span><span class="mi">86</span><span class="n">bfc16</span>
                    <span class="n">vid_cap_start_streaming</span>
                        <span class="n">vivid_start_generating_vid_cap</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 
 
<span class="n">CPU</span> <span class="mi">0</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
<span class="n">vb2_fop_read</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
    <span class="n">vb2_read</span>
        <span class="n">__vb2_perform_fileio</span>
            <span class="n">__vb2_wait_for_done_vb</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
 
 
<span class="n">CPU</span> <span class="mi">1</span> <span class="p">(</span><span class="n">READ</span><span class="p">)</span>
                            <span class="n">vivid_thread_vid_cap</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span>
                                <span class="n">vivid_thread_vid_cap_tick</span>
                                    <span class="n">vivid_fillbuff</span> <span class="p">(</span><span class="n">fill</span> <span class="n">buffer</span><span class="p">)</span> <span class="n">buf</span><span class="o">:</span><span class="mo">0000000060</span><span class="n">c02281</span>
</code></pre></div></div>

<p>crash는 136라인의 0x0000000060c02281 버퍼에 대해 vivid_fillbuff() 함수에서 어떤 작업을 하면서 발생한다. 이 buf 주소를 잘 살펴보면, 해당 주소는 89 라인의 __vb2_queue_free() 함수에서 kfree() 이후 NULL 로 초기화되는 주소이다.</p>

<p>해당 buf의 주소인 0x0000000060c02281 에 대해 다시 정리해보면 아래와 같다.</p>

<ol>
  <li>CPU 0 : __vb2_queue_alloc() 함수에서 buf 할당 (9라인)</li>
  <li>CPU 0 : vid_cap_buf_queue() 함수에서 vid_cap_active 에 추가 (18 라인)</li>
  <li>CPU 1 : vivid_stop_generating_vid_cap() 함수에서 vid_cap_active 에서 제거 (55 라인)</li>
  <li>CPU 0 : vid_cap_buf_queue() 함수에서 vid_cap_active 에 추가 (69 라인)</li>
  <li>__vb2_queue_free() 함수에서 kfree 후 NULL 로 초기화 (89 라인)</li>
  <li>vivid_fillbuff() 함수에서 buf 주소에 접근 시 NULL pointer dereference 로 crash 발생</li>
</ol>

<p><a href="/assets/images/cve-2019-18683/vivid_race_condtion.png"><img src="/assets/images/cve-2019-18683/vivid_race_condtion.png" alt="vivid_race_condtion" /></a></p>

<h2 id="exploit-분석">Exploit 분석</h2>

<p>현재 공개되어 있는 익스플로잇 코드는 없으나 참고할 수 있을만한 코드를 아래에서 다운로드 할 수 있다.
<br /><code class="language-plaintext highlighter-rouge">https://github.com/Limesss/cve-2019-18683</code></p>

<h2 id="reference">Reference</h2>

<p><a href="https://a13xp0p0v.github.io/2020/02/15/CVE-2019-18683.html">CVE-2019-18683: Exploiting a Linux kernel vulnerability in the V4L2 subsystem</a></p>

<p><a href="https://www.anquanke.com/post/id/200029">CVE-2019-18683 linux v4l2 漏洞分析</a></p>

<p><a href="http://thirdnsov.tistory.com/attachment/cfile5.uf@26022A3A57BBB8120F3A86.pdf">Video for Linux Ver.2(V4L2)</a></p>


        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#dev" class="page__taxonomy-item" rel="tag">dev</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/" class="page__taxonomy-item" rel="tag"></a><span class="sep">, </span>
    
      
      
      <a href="/categories/" class="page__taxonomy-item" rel="tag"></a><span class="sep">, </span>
    
      
      
      <a href="/categories/" class="page__taxonomy-item" rel="tag"></a><span class="sep">, </span>
    
      
      
      <a href="/categories/" class="page__taxonomy-item" rel="tag"></a><span class="sep">, </span>
    
      
      
      <a href="/categories/#vivid" class="page__taxonomy-item" rel="tag">vivid</a><span class="sep">, </span>
    
      
      
      <a href="/categories/#cve-2019-18683" class="page__taxonomy-item" rel="tag">CVE-2019-18683</a><span class="sep">, </span>
    
      
      
      <a href="/categories/#linux-kernel-exploits" class="page__taxonomy-item" rel="tag">linux-kernel-exploits</a>
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-08-02T00:00:00+09:00">August 2, 2021</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Linux+Kernel+Exploit+with+CVE-2019-18683%20https%3A%2F%2Flucid78.github.io%2Flinux-kernel-exploits%2C%2Fcve-2019-18683%2C%2Fvivid%2Fcve-2019-18683%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Flucid78.github.io%2Flinux-kernel-exploits%2C%2Fcve-2019-18683%2C%2Fvivid%2Fcve-2019-18683%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Flucid78.github.io%2Flinux-kernel-exploits%2C%2Fcve-2019-18683%2C%2Fvivid%2Fcve-2019-18683%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/linux-kernel-exploits,/cve-2017-7308/cve-2017-7308/" class="pagination--pager" title="linux kernel exploit 분석 - cve-2017-7308
">Previous</a>
    
    
      <a href="#" class="pagination--pager disabled">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/linux-kernel-exploits,/cve-2017-7308/cve-2017-7308/" rel="permalink">linux kernel exploit 분석 - cve-2017-7308
</a>
      
    </h2>
    


    <p class="archive__item-excerpt" itemprop="description">linux kernel exploitation
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/pwntools/pwntoolscpp-5/" rel="permalink">pwntools 개발기 (5)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          2 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">ELF 클래스에 함수 추가하기
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/pwntools/pwntoolscpp-4/" rel="permalink">pwntools 개발기 (4)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          23 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">got()를 추가하고 LAB4 공략
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/pwntools/pwntoolscpp-3/" rel="permalink">pwntools 개발기 (3)
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          18 minute read
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">ELF class 추가하기
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="Enter your search term..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
          <li><a href="https://github.com/lucid78" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
      
        
      
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 lucid7. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>







  </body>
</html>
